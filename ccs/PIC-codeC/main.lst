CCS PCH C Compiler, Version 5.094d, 1               03-mai-20 15:17
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   D:\Utilisateurs\Arnaud\Documents\GitHub\ElecDigital_Projet\ccs\PIC-codeC\main.lst

               ROM used:   2102 bytes (6%)
                           Largest free fragment is 30662
               RAM used:   49 (3%) at main() level
                           64 (4%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 31

0000:  GOTO   05CA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   00C2
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <main.h>
.................... #include <18F458.h>
.................... //////////// Standard Header file for the PIC18F458 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F458
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 28,0C
00C0:  DATA 01,06
*
00F4:  DATA 20,50
00F6:  DATA 72,6F
00F8:  DATA 6A,65
00FA:  DATA 74,20
00FC:  DATA 45,6C
00FE:  DATA 65,63
0100:  DATA 74,72
0102:  DATA 6F,6E
0104:  DATA 69,71
0106:  DATA 75,65
0108:  DATA 20,00
010A:  DATA 20,32
010C:  DATA 30,32
010E:  DATA 30,20
0110:  DATA 47,72
0112:  DATA 6F,75
0114:  DATA 70,65
0116:  DATA 20,33
0118:  DATA 20,00
011A:  DATA 20,4D
011C:  DATA 69,6E
011E:  DATA 56,61
0120:  DATA 6C,3A
0122:  DATA 20,00
0124:  DATA 20,44
0126:  DATA 69,73
0128:  DATA 74,61
012A:  DATA 6E,63
012C:  DATA 65,3A
012E:  DATA 20,00
*
0268:  ADDWF  FE8,W
026A:  CLRF   FF7
026C:  RLCF   FF7,F
026E:  ADDLW  83
0270:  MOVWF  FF6
0272:  MOVLW  02
0274:  ADDWFC FF7,F
0276:  TBLRD*-
0278:  MOVF   FF5,W
027A:  MOVWF  FFA
027C:  TBLRD*
027E:  MOVF   FF5,W
0280:  MOVWF  FF9
0282:  DATA 42,02
0284:  DATA 48,02
0286:  DATA 4E,02
0288:  DATA 54,02
*
02D2:  TBLRD*+
02D4:  MOVF   FF5,F
02D6:  BZ    02F0
02D8:  MOVFF  FF6,2F
02DC:  MOVFF  FF7,30
02E0:  MOVFF  FF5,35
02E4:  RCALL  028A
02E6:  MOVFF  2F,FF6
02EA:  MOVFF  30,FF7
02EE:  BRA    02D2
02F0:  RETURN 0
*
0356:  CLRF   01
0358:  CLRF   02
035A:  CLRF   00
035C:  CLRF   03
035E:  MOVF   35,W
0360:  BNZ   0366
0362:  MOVF   34,W
0364:  BZ    0396
0366:  MOVLW  10
0368:  MOVWF  36
036A:  BCF    FD8.0
036C:  RLCF   32,F
036E:  RLCF   33,F
0370:  RLCF   00,F
0372:  RLCF   03,F
0374:  MOVF   35,W
0376:  SUBWF  03,W
0378:  BNZ   037E
037A:  MOVF   34,W
037C:  SUBWF  00,W
037E:  BNC   038E
0380:  MOVF   34,W
0382:  SUBWF  00,F
0384:  BTFSS  FD8.0
0386:  DECF   03,F
0388:  MOVF   35,W
038A:  SUBWF  03,F
038C:  BSF    FD8.0
038E:  RLCF   01,F
0390:  RLCF   02,F
0392:  DECFSZ 36,F
0394:  BRA    036A
0396:  RETURN 0
0398:  MOVFF  FEA,37
039C:  MOVFF  FE9,36
03A0:  BTFSS  30.7
03A2:  BRA    03B4
03A4:  BSF    36.7
03A6:  BTFSS  36.4
03A8:  INCF   36,F
03AA:  COMF   2F,F
03AC:  COMF   30,F
03AE:  INCF   2F,F
03B0:  BTFSC  FD8.2
03B2:  INCF   30,F
03B4:  SWAPF  30,W
03B6:  IORLW  F0
03B8:  MOVWF  32
03BA:  ADDWF  32,F
03BC:  ADDLW  E2
03BE:  MOVWF  33
03C0:  ADDLW  32
03C2:  MOVWF  35
03C4:  MOVF   30,W
03C6:  ANDLW  0F
03C8:  ADDWF  33,F
03CA:  ADDWF  33,F
03CC:  ADDWF  35,F
03CE:  ADDLW  E9
03D0:  MOVWF  34
03D2:  ADDWF  34,F
03D4:  ADDWF  34,F
03D6:  SWAPF  2F,W
03D8:  ANDLW  0F
03DA:  ADDWF  34,F
03DC:  ADDWF  35,F
03DE:  RLCF   34,F
03E0:  RLCF   35,F
03E2:  COMF   35,F
03E4:  RLCF   35,F
03E6:  MOVF   2F,W
03E8:  ANDLW  0F
03EA:  ADDWF  35,F
03EC:  RLCF   32,F
03EE:  MOVLW  07
03F0:  MOVWF  31
03F2:  MOVLW  0A
03F4:  DECF   34,F
03F6:  ADDWF  35,F
03F8:  BNC   03F4
03FA:  DECF   33,F
03FC:  ADDWF  34,F
03FE:  BNC   03FA
0400:  DECF   32,F
0402:  ADDWF  33,F
0404:  BNC   0400
0406:  DECF   31,F
0408:  ADDWF  32,F
040A:  BNC   0406
040C:  CLRF   FEA
040E:  MOVLW  31
0410:  MOVWF  FE9
0412:  MOVLW  07
0414:  ANDWF  36,W
0416:  BCF    36.6
0418:  MOVF   FED,F
041A:  ANDWF  36,W
041C:  BNZ   042C
041E:  BTFSC  36.4
0420:  MOVF   FEE,F
0422:  BTFSC  36.4
0424:  BRA    042C
0426:  MOVLW  20
0428:  MOVWF  00
042A:  BRA    046C
042C:  ADDWF  FE9,F
042E:  MOVLW  00
0430:  ADDWFC FEA,F
0432:  MOVF   FE9,W
0434:  SUBLW  35
0436:  BNZ   043E
0438:  MOVF   FEA,F
043A:  BNZ   043E
043C:  BSF    36.6
043E:  MOVF   FEF,W
0440:  MOVWF  00
0442:  BNZ   0454
0444:  BTFSC  36.6
0446:  BRA    0454
0448:  BTFSC  36.4
044A:  BRA    0474
044C:  BTFSC  36.3
044E:  BRA    0454
0450:  MOVLW  20
0452:  BRA    046A
0454:  BTFSS  36.7
0456:  BRA    0464
0458:  MOVLW  2D
045A:  MOVWF  00
045C:  MOVF   FED,W
045E:  BCF    36.6
0460:  BCF    36.7
0462:  BRA    046C
0464:  BSF    36.3
0466:  BCF    36.4
0468:  MOVLW  30
046A:  ADDWF  00,F
046C:  MOVF   00,W
046E:  BTFSS  F9E.4
0470:  BRA    046E
0472:  MOVWF  FAD
0474:  MOVF   FEE,W
0476:  BTFSS  36.6
0478:  BRA    0432
047A:  GOTO   0678 (RETURN)
047E:  MOVF   36,W
0480:  CLRF   01
0482:  SUBWF  35,W
0484:  BC    048C
0486:  MOVFF  35,00
048A:  BRA    04A4
048C:  CLRF   00
048E:  MOVLW  08
0490:  MOVWF  37
0492:  RLCF   35,F
0494:  RLCF   00,F
0496:  MOVF   36,W
0498:  SUBWF  00,W
049A:  BTFSC  FD8.0
049C:  MOVWF  00
049E:  RLCF   01,F
04A0:  DECFSZ 37,F
04A2:  BRA    0492
04A4:  RETURN 0
04A6:  MOVLW  20
04A8:  BTFSS  30.4
04AA:  MOVLW  30
04AC:  MOVWF  31
04AE:  MOVFF  2F,00
04B2:  BTFSS  2F.7
04B4:  BRA    04C6
04B6:  COMF   00,F
04B8:  INCF   00,F
04BA:  MOVFF  00,2F
04BE:  MOVLW  2D
04C0:  MOVWF  31
04C2:  BSF    30.7
04C4:  BSF    30.0
04C6:  MOVF   01,W
04C8:  MOVFF  2F,35
04CC:  MOVLW  64
04CE:  MOVWF  36
04D0:  RCALL  047E
04D2:  MOVFF  00,2F
04D6:  MOVLW  30
04D8:  ADDWF  01,W
04DA:  MOVWF  32
04DC:  MOVFF  2F,35
04E0:  MOVLW  0A
04E2:  MOVWF  36
04E4:  RCALL  047E
04E6:  MOVLW  30
04E8:  ADDWF  00,W
04EA:  MOVWF  34
04EC:  MOVLW  30
04EE:  ADDWF  01,W
04F0:  MOVWF  33
04F2:  MOVFF  31,00
04F6:  MOVLW  30
04F8:  SUBWF  32,W
04FA:  BZ    0504
04FC:  BSF    30.1
04FE:  BTFSC  30.7
0500:  BSF    30.2
0502:  BRA    0528
0504:  MOVFF  31,32
0508:  MOVLW  20
050A:  MOVWF  31
050C:  MOVLW  30
050E:  SUBWF  33,W
0510:  BZ    051A
0512:  BSF    30.0
0514:  BTFSC  30.7
0516:  BSF    30.1
0518:  BRA    0528
051A:  BTFSS  FD8.2
051C:  BSF    30.0
051E:  BNZ   0528
0520:  MOVFF  32,33
0524:  MOVLW  20
0526:  MOVWF  32
0528:  BTFSC  30.2
052A:  BRA    0536
052C:  BTFSC  30.1
052E:  BRA    053C
0530:  BTFSC  30.0
0532:  BRA    0542
0534:  BRA    0548
0536:  MOVFF  31,35
053A:  RCALL  028A
053C:  MOVFF  32,35
0540:  RCALL  028A
0542:  MOVFF  33,35
0546:  RCALL  028A
0548:  MOVFF  34,35
054C:  RCALL  028A
054E:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=16
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... 
.................... #use delay(crystal=20MHz)
*
0130:  CLRF   FEA
0132:  MOVLW  36
0134:  MOVWF  FE9
0136:  MOVF   FEF,W
0138:  BZ    0154
013A:  MOVLW  06
013C:  MOVWF  01
013E:  CLRF   00
0140:  DECFSZ 00,F
0142:  BRA    0140
0144:  DECFSZ 01,F
0146:  BRA    013E
0148:  MOVLW  7B
014A:  MOVWF  00
014C:  DECFSZ 00,F
014E:  BRA    014C
0150:  DECFSZ FEF,F
0152:  BRA    013A
0154:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=0,rcv=0,bits=8,stream=PORT1)
.................... 
.................... #define LED PIN_None
.................... #define DELAY 1000
.................... 
.................... 
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... #include "LCD420.c"
.................... ///////////////////////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD420.C                                                  ////
.................... ////            Driver for common 4x20 LCD modules  (Fonction de haut niveau )             ////
.................... ////                                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.                               ////
.................... ////                                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.                         ////
.................... ////                     The following have special meaning:                               ////
.................... ////                      \f  Clear display                                                ////
.................... ////                      \n  Go to start of second line                                   ////
.................... ////                      \b  Move back one position                                       ////
.................... ////                                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1 -> 20,4)                ////
.................... ////                                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD                             ////
.................... ////                                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,1997 Custom Computer Services                               ////
.................... //// This source code may only be used by licensed users of the CCS C                      ////
.................... //// compiler.  This source code may only be distributed to other                          ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction                     ////
.................... //// or distribution is permitted without written permission.                              ////
.................... //// Derivative programs created using this software in object code                        ////
.................... //// form are not restricted in any way.                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // As defined in the following structure the pin connection is as follows:
.................... //     B0  enable
.................... //     B1  rs
.................... //     B2  rw
.................... //     B4  D4
.................... //     B5  D5
.................... //     B6  D6
.................... //     B7  D7
.................... //
.................... //   LCD pins D0-D3 are not used and PIC B3 is not used.
.................... 
.................... struct lcd_pin_map {                 // This structure is overlayed ( Mettre dans l'ordre de poid faible ? fort )
....................            int     data : 4;         // be pin B0.
....................            BOOLEAN rs;               // access to the LCD pins.
....................            BOOLEAN rw;               // The bits are allocated from
....................            BOOLEAN enable;           // on to an I/O port to gain
....................            BOOLEAN unused;           // low order up.  ENABLE will
.................... 
....................         } lcd;
.................... 
.................... #byte lcd = 0xF83                        // This puts the entire structure ( se trouve ? la page 47 du datasheet dans "SPECIAL FUNCTION REGISTER MAP" )
....................                                          // on to port B (at address 6)
.................... 
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines
.................... 
.................... 
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6};
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
.................... 
.................... 
....................                              // The following are used for setting
....................                              // the I/O port direction register.
.................... 
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out
.................... struct lcd_pin_map const LCD_READ = {15,0,0,0,0}; // For read mode data pins are in  ( 15 car les 4 bits du lcd doivent etre ? l'?tat haut et du cot? gauche car d?plac? en premiere ligne dans struct )
.................... 
.................... 
.................... BYTE lcdline;
.................... 
.................... BYTE lcd_read_byte() {  // Fonction de bas niveau
....................       BYTE low,high;
.................... 
....................       set_tris_d(LCD_READ);
*
0174:  MOVLW  0F
0176:  MOVWF  F95
....................       lcd.rw = 1;
0178:  BSF    F83.5
....................       delay_cycles(1);
017A:  NOP   
....................       lcd.enable = 1;
017C:  BSF    F83.6
....................       delay_cycles(1);
017E:  NOP   
....................       high = lcd.data;
0180:  MOVF   F83,W
0182:  ANDLW  0F
0184:  MOVWF  3C
....................       lcd.enable = 0;
0186:  BCF    F83.6
....................       delay_cycles(1);
0188:  NOP   
....................       lcd.enable = 1;
018A:  BSF    F83.6
....................       delay_us(1);
018C:  BRA    018E
018E:  BRA    0190
0190:  NOP   
....................       low = lcd.data;
0192:  MOVF   F83,W
0194:  ANDLW  0F
0196:  MOVWF  3B
....................       lcd.enable = 0;
0198:  BCF    F83.6
....................       set_tris_d(LCD_WRITE);
019A:  MOVLW  00
019C:  MOVWF  F95
....................       return( (high<<4) | low);
019E:  SWAPF  3C,W
01A0:  MOVWF  00
01A2:  MOVLW  F0
01A4:  ANDWF  00,F
01A6:  MOVF   00,W
01A8:  IORWF  3B,W
01AA:  MOVWF  01
01AC:  GOTO   01B4 (RETURN)
.................... }
.................... 
.................... 
.................... void lcd_send_nibble( BYTE n ) {  // Fonction de bas niveau
....................       lcd.data = n;
*
0156:  MOVF   3C,W
0158:  ANDLW  0F
015A:  MOVWF  00
015C:  MOVLW  F0
015E:  ANDWF  F83,W
0160:  IORWF  00,W
0162:  MOVWF  F83
....................       delay_cycles(1);
0164:  NOP   
....................       lcd.enable = 1;
0166:  BSF    F83.6
....................       delay_us(2);
0168:  MOVLW  03
016A:  MOVWF  00
016C:  DECFSZ 00,F
016E:  BRA    016C
....................       lcd.enable = 0;
0170:  BCF    F83.6
0172:  RETURN 0
.................... }
.................... 
.................... 
.................... void lcd_send_byte( BYTE address, BYTE n ) {  // Fonction de bas niveau
.................... 
....................       lcd.rs = 0;
*
01B0:  BCF    F83.4
....................       while ( bit_test(lcd_read_byte(),7) ) ;
01B2:  BRA    0174
01B4:  MOVFF  01,3B
01B8:  BTFSC  01.7
01BA:  BRA    01B2
....................       lcd.rs = address;
01BC:  BTFSS  39.0
01BE:  BCF    F83.4
01C0:  BTFSC  39.0
01C2:  BSF    F83.4
....................       delay_cycles(1);
01C4:  NOP   
....................       lcd.rw = 0;
01C6:  BCF    F83.5
....................       delay_cycles(1);
01C8:  NOP   
....................       lcd.enable = 0;
01CA:  BCF    F83.6
....................       lcd_send_nibble(n >> 4);
01CC:  SWAPF  3A,W
01CE:  MOVWF  3B
01D0:  MOVLW  0F
01D2:  ANDWF  3B,F
01D4:  MOVFF  3B,3C
01D8:  RCALL  0156
....................       lcd_send_nibble(n & 0xf);
01DA:  MOVF   3A,W
01DC:  ANDLW  0F
01DE:  MOVWF  3B
01E0:  MOVWF  3C
01E2:  RCALL  0156
01E4:  RETURN 0
.................... }
.................... 
.................... 
.................... void lcd_init() {
....................     BYTE i;
.................... 
....................     set_tris_d(LCD_WRITE);
01E6:  MOVLW  00
01E8:  MOVWF  F95
....................     lcd.rs = 0;
01EA:  BCF    F83.4
....................     lcd.rw = 0;
01EC:  BCF    F83.5
....................     lcd.enable = 0;
01EE:  BCF    F83.6
....................     delay_ms(15);
01F0:  MOVLW  0F
01F2:  MOVWF  36
01F4:  RCALL  0130
....................     for(i=1;i<=3;++i) {
01F6:  MOVLW  01
01F8:  MOVWF  2F
01FA:  MOVF   2F,W
01FC:  SUBLW  03
01FE:  BNC   0210
....................        lcd_send_nibble(3);
0200:  MOVLW  03
0202:  MOVWF  3C
0204:  RCALL  0156
....................        delay_ms(5);
0206:  MOVLW  05
0208:  MOVWF  36
020A:  RCALL  0130
020C:  INCF   2F,F
020E:  BRA    01FA
....................     }
....................     lcd_send_nibble(2);
0210:  MOVLW  02
0212:  MOVWF  3C
0214:  RCALL  0156
....................     for(i=0;i<=3;++i)
0216:  CLRF   2F
0218:  MOVF   2F,W
021A:  SUBLW  03
021C:  BNC   0230
....................        lcd_send_byte(0, LCD_INIT_STRING[i]);
021E:  CLRF   03
0220:  MOVF   2F,W
0222:  RCALL  00AE
0224:  MOVWF  30
0226:  CLRF   39
0228:  MOVWF  3A
022A:  RCALL  01B0
022C:  INCF   2F,F
022E:  BRA    0218
0230:  GOTO   0626 (RETURN)
.................... }
.................... 
.................... 
.................... void lcd_gotoxy( BYTE x, BYTE y) {
....................    BYTE address;
.................... 
....................    switch(y) {
0234:  MOVLW  01
0236:  SUBWF  37,W
0238:  ADDLW  FC
023A:  BC    0258
023C:  ADDLW  04
023E:  GOTO   0268
....................      case 1 : address=0x80;break;
0242:  MOVLW  80
0244:  MOVWF  38
0246:  BRA    0258
....................      case 2 : address=0xc0;break;
0248:  MOVLW  C0
024A:  MOVWF  38
024C:  BRA    0258
....................      case 3 : address=0x94;break;
024E:  MOVLW  94
0250:  MOVWF  38
0252:  BRA    0258
....................      case 4 : address=0xd4;break;
0254:  MOVLW  D4
0256:  MOVWF  38
....................    }
....................    address+=x-1;
0258:  MOVLW  01
025A:  SUBWF  36,W
025C:  ADDWF  38,F
....................    lcd_send_byte(0,address);
025E:  CLRF   39
0260:  MOVFF  38,3A
0264:  RCALL  01B0
0266:  RETURN 0
.................... }
.................... 
.................... void lcd_putc( char c) {
....................    switch (c) {
*
028A:  MOVF   35,W
028C:  XORLW  0C
028E:  BZ    029A
0290:  XORLW  06
0292:  BZ    02AE
0294:  XORLW  02
0296:  BZ    02BC
0298:  BRA    02C6
....................      case '\f'   : lcd_send_byte(0,1);
029A:  CLRF   39
029C:  MOVLW  01
029E:  MOVWF  3A
02A0:  RCALL  01B0
....................                    lcdline=1;
02A2:  MOVLW  01
02A4:  MOVWF  19
....................                    delay_ms(2);
02A6:  MOVLW  02
02A8:  MOVWF  36
02AA:  RCALL  0130
....................                                            break;
02AC:  BRA    02D0
....................      case '\n'   : lcd_gotoxy(1,++lcdline);        break;
02AE:  INCF   19,F
02B0:  MOVLW  01
02B2:  MOVWF  36
02B4:  MOVFF  19,37
02B8:  RCALL  0234
02BA:  BRA    02D0
....................      case '\b'   : lcd_send_byte(0,0x10);  break;
02BC:  CLRF   39
02BE:  MOVLW  10
02C0:  MOVWF  3A
02C2:  RCALL  01B0
02C4:  BRA    02D0
....................      default     : lcd_send_byte(1,c);     break;
02C6:  MOVLW  01
02C8:  MOVWF  39
02CA:  MOVFF  35,3A
02CE:  RCALL  01B0
....................    }
02D0:  RETURN 0
.................... }
.................... 
.................... char lcd_getc( BYTE x, BYTE y) {
....................    char value;
.................... 
....................     lcd_gotoxy(x,y);
....................     lcd.rs=1;
....................     value = lcd_read_byte();
....................     lcd.rs=0;
....................     return(value);
.................... }
.................... 
.................... 
.................... #use fast_io(C)
.................... 
.................... #use rs232(baud=9600, parity=N, xmit=PIN_C6, rcv=PIN_C7)
.................... 
.................... #define trigger pin_C0
.................... #define echo pin_C1
.................... #define dot pin_E2
.................... #define RX pin_C7
.................... #define TX pin_C6
.................... #define GREEN pin_E0
.................... #define RED pin_E1
.................... 
.................... #int_TIMER1
.................... 
.................... int16 time, distance, x, i, minVal;
.................... bool flag=0;
.................... char buffer[4];
.................... int j=0;
.................... int8 c,d,u;
.................... 
.................... #INT_RDA
.................... void RDA_isr(void) {
....................   buffer[j]=getc();
*
00C2:  CLRF   03
00C4:  MOVF   29,W
00C6:  ADDLW  25
00C8:  MOVWF  FE9
00CA:  MOVLW  00
00CC:  ADDWFC 03,W
00CE:  MOVWF  FEA
00D0:  BTFSS  F9E.5
00D2:  BRA    00D0
00D4:  MOVFF  FAE,FEF
....................   if(buffer[0]=='!' && flag==0) {
00D8:  MOVF   25,W
00DA:  SUBLW  21
00DC:  BNZ   00EE
00DE:  BTFSC  24.0
00E0:  BRA    00EE
....................     j++;
00E2:  INCF   29,F
....................     if(j>=4) {
00E4:  MOVF   29,W
00E6:  SUBLW  03
00E8:  BC    00EE
....................       j=0;
00EA:  CLRF   29
....................       flag=1;
00EC:  BSF    24.0
....................     }
....................   }
00EE:  BCF    F9E.5
00F0:  GOTO   0060
.................... }
.................... 
.................... /*
.................... * transofmation de la valeur en valeur base 16
.................... */
.................... int16 outputValueParser(int16 value){
*
0550:  CLRF   31
....................    int output = 0;
....................    if (value < 10) { output = value;}
0552:  MOVF   30,F
0554:  BNZ   0562
0556:  MOVF   2F,W
0558:  SUBLW  09
055A:  BNC   0562
055C:  MOVFF  2F,31
0560:  BRA    05C0
....................    else {
....................     x = value;
0562:  MOVFF  30,1F
0566:  MOVFF  2F,1E
....................     x = x % 10;
056A:  MOVFF  1F,33
056E:  MOVFF  1E,32
0572:  CLRF   35
0574:  MOVLW  0A
0576:  MOVWF  34
0578:  RCALL  0356
057A:  MOVFF  00,1E
057E:  MOVFF  03,1F
....................     i = value;
0582:  MOVFF  30,21
0586:  MOVFF  2F,20
....................     i = i/10;
058A:  MOVFF  21,33
058E:  MOVFF  20,32
0592:  CLRF   35
0594:  MOVLW  0A
0596:  MOVWF  34
0598:  RCALL  0356
059A:  MOVFF  02,21
059E:  MOVFF  01,20
.................... 
....................     output = x + i*16;
05A2:  RLCF   20,W
05A4:  MOVWF  02
05A6:  RLCF   21,W
05A8:  MOVWF  03
05AA:  RLCF   02,F
05AC:  RLCF   03,F
05AE:  RLCF   02,F
05B0:  RLCF   03,F
05B2:  RLCF   02,F
05B4:  RLCF   03,F
05B6:  MOVLW  F0
05B8:  ANDWF  02,F
05BA:  MOVF   02,W
05BC:  ADDWF  1E,W
05BE:  MOVWF  31
....................    }
....................    return output;
05C0:  MOVFF  31,01
05C4:  CLRF   02
05C6:  GOTO   0822 (RETURN)
.................... }
.................... 
.................... /*
.................... * trigger de la sonde
.................... */
.................... void triggerSonde(){
....................    output_high(trigger);
*
0344:  BSF    F8B.0
....................    delay_us(10);
0346:  MOVLW  10
0348:  MOVWF  00
034A:  DECFSZ 00,F
034C:  BRA    034A
034E:  NOP   
....................    output_low(trigger);
0350:  BCF    F8B.0
0352:  GOTO   0634 (RETURN)
.................... }
.................... 
.................... /*
.................... * Fonctione d'initalisation du LCD
.................... */
.................... void init_lcd(){
....................    delay_ms(500);
*
02F2:  MOVLW  02
02F4:  MOVWF  2F
02F6:  MOVLW  FA
02F8:  MOVWF  36
02FA:  RCALL  0130
02FC:  DECFSZ 2F,F
02FE:  BRA    02F6
....................    lcd_putc('\f');
0300:  MOVLW  0C
0302:  MOVWF  35
0304:  RCALL  028A
....................    lcd_gotoxy(1,1);
0306:  MOVLW  01
0308:  MOVWF  36
030A:  MOVWF  37
030C:  RCALL  0234
....................    printf(lcd_putc," Projet Electronique ");
030E:  MOVLW  F4
0310:  MOVWF  FF6
0312:  MOVLW  00
0314:  MOVWF  FF7
0316:  RCALL  02D2
....................    lcd_gotoxy(1,3);
0318:  MOVLW  01
031A:  MOVWF  36
031C:  MOVLW  03
031E:  MOVWF  37
0320:  RCALL  0234
....................    printf(lcd_putc," 2020 Groupe 3 ");
0322:  MOVLW  0A
0324:  MOVWF  FF6
0326:  MOVLW  01
0328:  MOVWF  FF7
032A:  RCALL  02D2
....................    delay_ms(1000);
032C:  MOVLW  04
032E:  MOVWF  2F
0330:  MOVLW  FA
0332:  MOVWF  36
0334:  RCALL  0130
0336:  DECFSZ 2F,F
0338:  BRA    0330
....................    lcd_putc('\f');
033A:  MOVLW  0C
033C:  MOVWF  35
033E:  RCALL  028A
0340:  GOTO   0628 (RETURN)
.................... }
.................... 
.................... 
.................... /*
.................... * fonction principale
.................... */
.................... void main()
*
05CA:  CLRF   FF8
05CC:  BCF    FD0.7
05CE:  BSF    07.7
05D0:  BSF    00.0
05D2:  MOVLW  81
05D4:  MOVWF  FAF
05D6:  MOVLW  A6
05D8:  MOVWF  FAC
05DA:  MOVLW  90
05DC:  MOVWF  FAB
05DE:  BCF    24.0
05E0:  CLRF   29
05E2:  CLRF   2E
05E4:  CLRF   2D
05E6:  BSF    FC1.0
05E8:  BSF    FC1.1
05EA:  BSF    FC1.2
05EC:  BCF    FC1.3
05EE:  MOVLW  07
05F0:  MOVWF  FB4
.................... {
....................    setup_low_volt_detect(FALSE);
05F2:  CLRF   FD2
....................    set_tris_c(0b01000010); // set RC1 as input (ECHO)
05F4:  MOVLW  42
05F6:  MOVWF  F94
.................... 
....................    setup_spi(FALSE);
05F8:  CLRF   FC6
....................    setup_wdt(WDT_OFF);
05FA:  BCF    FD1.0
....................    setup_timer_1( T1_INTERNAL | T1_DIV_BY_1  );
05FC:  MOVLW  85
05FE:  MOVWF  FCD
....................    setup_comparator(NC_NC_NC_NC);
0600:  MOVLW  07
0602:  MOVWF  FB4
0604:  MOVF   F95,W
0606:  MOVWF  F95
0608:  MOVF   F96,W
060A:  MOVWF  F96
060C:  MOVLW  10
060E:  MOVWF  00
0610:  DECFSZ 00,F
0612:  BRA    0610
0614:  NOP   
0616:  MOVF   FB4,W
0618:  BCF    FA1.6
....................    setup_vref(FALSE);
061A:  CLRF   FB5
.................... 
....................    enable_interrupts(INT_RDA); // interuption sur r�ception port RS232
061C:  BSF    F9D.5
....................    enable_interrupts(GLOBAL);
061E:  MOVLW  C0
0620:  IORWF  FF2,F
....................    setup_oscillator(False);
0622:  CLRF   FD3
.................... 
....................    lcd_init();
0624:  BRA    01E6
....................    init_lcd();
0626:  BRA    02F2
.................... 
....................    while(true)
....................    {
.................... 
....................    // setup des valeurs
....................    time = 0;
0628:  CLRF   1B
062A:  CLRF   1A
.................... 
....................    // recuperation minValue envoye par JAVA
....................    minVal = 100;
062C:  CLRF   23
062E:  MOVLW  64
0630:  MOVWF  22
.................... 
....................    // d�clanchement de la sonde
....................    triggerSonde();
0632:  BRA    0344
.................... 
....................    // recuperation valeur temps de la sonde
....................    while(input(echo) == 0){} // attente debut
0634:  BTFSS  F82.1
0636:  BRA    0634
....................    set_timer1(0);
0638:  CLRF   FCF
063A:  CLRF   FCE
....................    while(input(echo) == 1){} // attente fin
063C:  BTFSC  F82.1
063E:  BRA    063C
....................    time = get_timer1();
0640:  MOVF   FCE,W
0642:  MOVWF  1A
0644:  MOVFF  FCF,1B
.................... 
....................    // temps => distance
....................    distance = time/285;
0648:  MOVFF  1B,33
064C:  MOVFF  1A,32
0650:  MOVLW  01
0652:  MOVWF  35
0654:  MOVLW  1D
0656:  MOVWF  34
0658:  RCALL  0356
065A:  MOVFF  02,1D
065E:  MOVFF  01,1C
.................... 
....................    // envoie distance ici java
....................    printf(" %ld", distance);
0662:  MOVLW  20
0664:  BTFSS  F9E.4
0666:  BRA    0664
0668:  MOVWF  FAD
066A:  MOVLW  10
066C:  MOVWF  FE9
066E:  MOVFF  1D,30
0672:  MOVFF  1C,2F
0676:  BRA    0398
....................    printf("\n");
0678:  MOVLW  0A
067A:  BTFSS  F9E.4
067C:  BRA    067A
067E:  MOVWF  FAD
.................... 
....................    // si donn�es recu depuis java sur RS232 > interuption INT_RSA
....................    if(flag==1){
0680:  BTFSS  24.0
0682:  BRA    06AE
....................      flag=0;
0684:  BCF    24.0
....................      c=buffer[1]-48;
0686:  MOVLW  30
0688:  SUBWF  26,W
068A:  MOVWF  2A
....................      d=buffer[2]-48;
068C:  MOVLW  30
068E:  SUBWF  27,W
0690:  MOVWF  2B
....................      u=buffer[3]-48;
0692:  MOVLW  30
0694:  SUBWF  28,W
0696:  MOVWF  2C
....................      minVal=(int16) (c*100+d*10+u);
0698:  MOVF   2A,W
069A:  MULLW  64
069C:  MOVFF  FF3,2F
06A0:  MOVF   2B,W
06A2:  MULLW  0A
06A4:  MOVF   FF3,W
06A6:  ADDWF  2F,W
06A8:  ADDWF  2C,W
06AA:  CLRF   23
06AC:  MOVWF  22
....................    }
.................... 
....................    // cr�ation valeurs LCD MINvalue
....................    c = minVal/100;
06AE:  MOVFF  23,33
06B2:  MOVFF  22,32
06B6:  CLRF   35
06B8:  MOVLW  64
06BA:  MOVWF  34
06BC:  RCALL  0356
06BE:  MOVFF  01,2A
....................    d = (minVal-(c*100))/10;
06C2:  MOVF   2A,W
06C4:  MULLW  64
06C6:  MOVF   FF3,W
06C8:  SUBWF  22,W
06CA:  MOVWF  2F
06CC:  MOVLW  00
06CE:  SUBWFB 23,W
06D0:  MOVWF  30
06D2:  MOVWF  33
06D4:  MOVFF  2F,32
06D8:  CLRF   35
06DA:  MOVLW  0A
06DC:  MOVWF  34
06DE:  RCALL  0356
06E0:  MOVFF  01,2B
....................    u = (minVal-(c*100))-(d*10);
06E4:  MOVF   2A,W
06E6:  MULLW  64
06E8:  MOVF   FF3,W
06EA:  SUBWF  22,W
06EC:  MOVWF  2F
06EE:  MOVLW  00
06F0:  SUBWFB 23,W
06F2:  MOVF   2B,W
06F4:  MULLW  0A
06F6:  MOVF   FF3,W
06F8:  SUBWF  2F,W
06FA:  MOVWF  2C
....................    // Affichage MinValue LCD
....................    lcd_gotoxy(3,1);
06FC:  MOVLW  03
06FE:  MOVWF  36
0700:  MOVLW  01
0702:  MOVWF  37
0704:  RCALL  0234
....................    printf(lcd_putc, " MinVal: ");
0706:  MOVLW  1A
0708:  MOVWF  FF6
070A:  MOVLW  01
070C:  MOVWF  FF7
070E:  RCALL  02D2
....................    printf(lcd_putc, "%d", c);
0710:  MOVFF  2A,2F
0714:  MOVLW  18
0716:  MOVWF  30
0718:  RCALL  04A6
....................    printf(lcd_putc, "%d", d);
071A:  MOVFF  2B,2F
071E:  MOVLW  18
0720:  MOVWF  30
0722:  RCALL  04A6
....................    printf(lcd_putc, "%d", u);
0724:  MOVFF  2C,2F
0728:  MOVLW  18
072A:  MOVWF  30
072C:  RCALL  04A6
....................    // cr�eation valeurs Distance LCD
....................    c = distance/100;
072E:  MOVFF  1D,33
0732:  MOVFF  1C,32
0736:  CLRF   35
0738:  MOVLW  64
073A:  MOVWF  34
073C:  RCALL  0356
073E:  MOVFF  01,2A
....................    d = (distance-(c*100))/10;
0742:  MOVF   2A,W
0744:  MULLW  64
0746:  MOVF   FF3,W
0748:  SUBWF  1C,W
074A:  MOVWF  2F
074C:  MOVLW  00
074E:  SUBWFB 1D,W
0750:  MOVWF  30
0752:  MOVWF  33
0754:  MOVFF  2F,32
0758:  CLRF   35
075A:  MOVLW  0A
075C:  MOVWF  34
075E:  RCALL  0356
0760:  MOVFF  01,2B
....................    u = (distance-(c*100))-(d*10);
0764:  MOVF   2A,W
0766:  MULLW  64
0768:  MOVF   FF3,W
076A:  SUBWF  1C,W
076C:  MOVWF  2F
076E:  MOVLW  00
0770:  SUBWFB 1D,W
0772:  MOVF   2B,W
0774:  MULLW  0A
0776:  MOVF   FF3,W
0778:  SUBWF  2F,W
077A:  MOVWF  2C
....................    // affichage distance LCD
....................    lcd_gotoxy(3,3);
077C:  MOVLW  03
077E:  MOVWF  36
0780:  MOVWF  37
0782:  RCALL  0234
....................    printf(lcd_putc, " Distance: ");
0784:  MOVLW  24
0786:  MOVWF  FF6
0788:  MOVLW  01
078A:  MOVWF  FF7
078C:  RCALL  02D2
....................    printf(lcd_putc, "%d", c);
078E:  MOVFF  2A,2F
0792:  MOVLW  18
0794:  MOVWF  30
0796:  RCALL  04A6
....................    printf(lcd_putc, "%d", d);
0798:  MOVFF  2B,2F
079C:  MOVLW  18
079E:  MOVWF  30
07A0:  RCALL  04A6
....................    printf(lcd_putc, "%d", u);
07A2:  MOVFF  2C,2F
07A6:  MOVLW  18
07A8:  MOVWF  30
07AA:  RCALL  04A6
.................... 
....................    // v�rification borne minVal
....................    if (distance < minVal){
07AC:  MOVF   1D,W
07AE:  SUBWF  23,W
07B0:  BNC   07D4
07B2:  BNZ   07BA
07B4:  MOVF   22,W
07B6:  SUBWF  1C,W
07B8:  BC    07D4
....................       // allumer red => trop proche
....................       printf("1\n");
07BA:  MOVLW  31
07BC:  BTFSS  F9E.4
07BE:  BRA    07BC
07C0:  MOVWF  FAD
07C2:  MOVLW  0A
07C4:  BTFSS  F9E.4
07C6:  BRA    07C4
07C8:  MOVWF  FAD
....................       output_high(RED);
07CA:  BCF    F96.1
07CC:  BSF    F8D.1
....................       output_low(GREEN);
07CE:  BCF    F96.0
07D0:  BCF    F8D.0
....................    }
07D2:  BRA    07EC
....................    else {
....................       // allumer green => OK
....................       printf("2\n");
07D4:  MOVLW  32
07D6:  BTFSS  F9E.4
07D8:  BRA    07D6
07DA:  MOVWF  FAD
07DC:  MOVLW  0A
07DE:  BTFSS  F9E.4
07E0:  BRA    07DE
07E2:  MOVWF  FAD
....................       output_high(GREEN);
07E4:  BCF    F96.0
07E6:  BSF    F8D.0
....................       output_low(RED);
07E8:  BCF    F96.1
07EA:  BCF    F8D.1
....................    }
.................... 
....................    // gestion du point si > que 100 !> cm -> m
....................    if(distance > 99){
07EC:  MOVF   1D,F
07EE:  BNZ   07F6
07F0:  MOVF   1C,W
07F2:  SUBLW  63
07F4:  BC    0814
....................       distance = distance / 10;
07F6:  MOVFF  1D,33
07FA:  MOVFF  1C,32
07FE:  CLRF   35
0800:  MOVLW  0A
0802:  MOVWF  34
0804:  RCALL  0356
0806:  MOVFF  02,1D
080A:  MOVFF  01,1C
....................       output_high(dot);
080E:  BCF    F96.2
0810:  BSF    F8D.2
....................    }
0812:  BRA    0818
....................    else {
....................       output_low(dot);
0814:  BCF    F96.2
0816:  BCF    F8D.2
....................    }
.................... 
....................    // affichage sur 7seg de la distance
....................    output_b(outputValueParser(distance));
0818:  MOVFF  1D,30
081C:  MOVFF  1C,2F
0820:  BRA    0550
0822:  CLRF   F93
0824:  MOVFF  01,F8A
.................... 
.................... 
....................    // attente pour eviter spam
....................    delay_ms(500);
0828:  MOVLW  02
082A:  MOVWF  2F
082C:  MOVLW  FA
082E:  MOVWF  36
0830:  RCALL  0130
0832:  DECFSZ 2F,F
0834:  BRA    082C
0836:  BRA    0628
....................    }
.................... 
.................... }
0838:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   PUT NOBROWNOUT BORV25 NOWDT WDT128
   Word  3: 0000  
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
