CCS PCH C Compiler, Version 5.008, 5967               23-avr.-20 17:51

               Filename:   W:\Ephec\ElecDigitalProjet\ccs\PIC-codeC\main.lst

               ROM used:   498 bytes (2%)
                           Largest free fragment is 32270
               RAM used:   16 (1%) at main() level
                           22 (1%) worst case
               Stack used: 2 locations
               Stack size: 31

*
0000:  GOTO   0126
.................... #include <main.h> 
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
*
0016:  CLRF   01
0018:  CLRF   02
001A:  CLRF   00
001C:  CLRF   03
001E:  MOVF   14,W
0020:  BNZ   0026
0022:  MOVF   13,W
0024:  BZ    0056
0026:  MOVLW  10
0028:  MOVWF  15
002A:  BCF    FD8.0
002C:  RLCF   11,F
002E:  RLCF   12,F
0030:  RLCF   00,F
0032:  RLCF   03,F
0034:  MOVF   14,W
0036:  SUBWF  03,W
0038:  BNZ   003E
003A:  MOVF   13,W
003C:  SUBWF  00,W
003E:  BNC   004E
0040:  MOVF   13,W
0042:  SUBWF  00,F
0044:  BTFSS  FD8.0
0046:  DECF   03,F
0048:  MOVF   14,W
004A:  SUBWF  03,F
004C:  BSF    FD8.0
004E:  RLCF   01,F
0050:  RLCF   02,F
0052:  DECFSZ 15,F
0054:  BRA    002A
0056:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20MHz) 
*
00FE:  CLRF   FEA
0100:  MOVLW  0F
0102:  MOVWF  FE9
0104:  MOVF   FEF,W
0106:  BZ    0122
0108:  MOVLW  06
010A:  MOVWF  01
010C:  CLRF   00
010E:  DECFSZ 00,F
0110:  BRA    010E
0112:  DECFSZ 01,F
0114:  BRA    010C
0116:  MOVLW  7B
0118:  MOVWF  00
011A:  DECFSZ 00,F
011C:  BRA    011A
011E:  DECFSZ FEF,F
0120:  BRA    0108
0122:  GOTO   01EA (RETURN)
.................... #use rs232(baud=9600,parity=N,xmit=0,rcv=0,bits=8,stream=PORT1) 
....................  
.................... #define LED PIN_None 
.................... #define DELAY 1000 
....................  
....................  
....................  
.................... #use fast_io(C) 
....................  
.................... #use rs232(baud=19200, parity=N, xmit=PIN_C6, rcv=PIN_C7) 
*
0076:  BTFSS  F9E.4
0078:  BRA    0076
007A:  MOVWF  FAD
007C:  GOTO   01A4 (RETURN)
....................  
.................... #define trigger pin_C0 
.................... #define echo pin_C1 
.................... #define dot pin_E2 
.................... #define RX pin_C7 
.................... #define TX pin_C6 
.................... #define GREEN pin_E0 
.................... #define RED pin_E1 
....................  
.................... #int_TIMER1 
....................  
.................... int16 time, distance, x, i, minVal; 
....................  
.................... /* 
.................... * transofmation de la valeur en valeur base 16 
.................... */ 
.................... int16 outputValueParser(int16 value){ 
0080:  CLRF   10
....................    int output = 0; 
....................    if (value < 10) { output = value;} 
0082:  MOVF   0F,F
0084:  BNZ   0092
0086:  MOVF   0E,W
0088:  SUBLW  09
008A:  BNC   0092
008C:  MOVFF  0E,10
0090:  BRA    00F0
....................    else { 
....................     x = value; 
0092:  MOVFF  0F,09
0096:  MOVFF  0E,08
....................     x = x % 10; 
009A:  MOVFF  09,12
009E:  MOVFF  08,11
00A2:  CLRF   14
00A4:  MOVLW  0A
00A6:  MOVWF  13
00A8:  RCALL  0016
00AA:  MOVFF  00,08
00AE:  MOVFF  03,09
....................     i = value; 
00B2:  MOVFF  0F,0B
00B6:  MOVFF  0E,0A
....................     i = i/10; 
00BA:  MOVFF  0B,12
00BE:  MOVFF  0A,11
00C2:  CLRF   14
00C4:  MOVLW  0A
00C6:  MOVWF  13
00C8:  RCALL  0016
00CA:  MOVFF  02,0B
00CE:  MOVFF  01,0A
....................      
....................     output = x + i*16; 
00D2:  RLCF   0A,W
00D4:  MOVWF  02
00D6:  RLCF   0B,W
00D8:  MOVWF  03
00DA:  RLCF   02,F
00DC:  RLCF   03,F
00DE:  RLCF   02,F
00E0:  RLCF   03,F
00E2:  RLCF   02,F
00E4:  RLCF   03,F
00E6:  MOVLW  F0
00E8:  ANDWF  02,F
00EA:  MOVF   02,W
00EC:  ADDWF  08,W
00EE:  MOVWF  10
....................    } 
....................    return output; 
00F0:  CLRF   03
00F2:  MOVFF  10,01
00F6:  MOVFF  03,02
00FA:  GOTO   01DA (RETURN)
.................... } 
....................  
.................... /* 
.................... * parsing temps => distance 
.................... */ 
.................... int16 parseDist(int16 time){ 
....................   return time / (285) ; // theoriquement 343 m/s 
*
0058:  MOVFF  0F,12
005C:  MOVFF  0E,11
0060:  MOVLW  01
0062:  MOVWF  14
0064:  MOVLW  1D
0066:  MOVWF  13
0068:  RCALL  0016
006A:  MOVFF  02,03
006E:  MOVFF  02,02
0072:  GOTO   0178 (RETURN)
.................... } 
....................  
.................... /* 
.................... * trigger de la sonde 
.................... */ 
.................... void triggerSonde(){ 
....................    output_high(trigger); 
*
0004:  BSF    F8B.0
....................    delay_us(10); 
0006:  MOVLW  10
0008:  MOVWF  00
000A:  DECFSZ 00,F
000C:  BRA    000A
000E:  NOP   
....................    output_low(trigger); 
0010:  BCF    F8B.0
0012:  GOTO   015A (RETURN)
.................... } 
....................  
.................... /* 
.................... * fonction principale 
.................... */ 
.................... void main() 
*
0126:  CLRF   FF8
0128:  BCF    FD0.7
012A:  BSF    00.0
012C:  MOVLW  40
012E:  MOVWF  FAF
0130:  MOVLW  A6
0132:  MOVWF  FAC
0134:  MOVLW  90
0136:  MOVWF  FAB
0138:  BSF    FC1.0
013A:  BSF    FC1.1
013C:  BSF    FC1.2
013E:  BCF    FC1.3
0140:  MOVLW  07
0142:  MOVWF  FB4
.................... { 
....................    setup_low_volt_detect(FALSE); 
0144:  CLRF   FD2
....................    set_tris_c(0b01000010); // set RC1 as input (ECHO) 
0146:  MOVLW  42
0148:  MOVWF  F94
....................     
....................    setup_timer_1( T1_INTERNAL | T1_DIV_BY_1  ); 
014A:  MOVLW  85
014C:  MOVWF  FCD
....................     
....................    while(true) 
....................    { 
....................     
....................    // setup des valeurs et récupération minValue envoyé par JAVA 
....................    minVal = 100; 
014E:  CLRF   0D
0150:  MOVLW  64
0152:  MOVWF  0C
....................    time = 0; 
0154:  CLRF   05
0156:  CLRF   04
....................    // déclanchement de la sonde 
....................    triggerSonde(); 
0158:  BRA    0004
....................     
....................    // récupération valeur temps de la sonde 
....................    while(input(echo) == 0){} // attente début 
015A:  BTFSS  F82.1
015C:  BRA    015A
....................    set_timer1(0); 
015E:  CLRF   FCF
0160:  CLRF   FCE
....................    while(input(echo) == 1){} // attente fin ou overflow 
0162:  BTFSC  F82.1
0164:  BRA    0162
....................    time = get_timer1(); 
0166:  MOVF   FCE,W
0168:  MOVWF  04
016A:  MOVFF  FCF,05
....................     
....................    // temps => distance 
....................    distance = parseDist(time); 
016E:  MOVFF  05,0F
0172:  MOVFF  04,0E
0176:  BRA    0058
0178:  MOVFF  02,07
017C:  MOVFF  01,06
....................     
....................    // vérification borne minVal 
....................    if (distance < minVal){ 
0180:  MOVF   07,W
0182:  SUBWF  0D,W
0184:  BNC   0198
0186:  BNZ   018E
0188:  MOVF   0C,W
018A:  SUBWF  06,W
018C:  BC    0198
....................       // allumer red => trop proche 
....................       output_high(RED); 
018E:  BCF    F96.1
0190:  BSF    F8D.1
....................       output_low(GREEN); 
0192:  BCF    F96.0
0194:  BCF    F8D.0
....................    } 
0196:  BRA    01A0
....................    else { 
....................       // allumer green => OK 
....................       output_high(GREEN); 
0198:  BCF    F96.0
019A:  BSF    F8D.0
....................       output_low(RED); 
019C:  BCF    F96.1
019E:  BCF    F8D.1
....................    } 
....................     
....................    // envois distance JAVA 
....................    putc(distance); 
01A0:  MOVF   06,W
01A2:  BRA    0076
....................     
....................    // gestion du point si > que 100 !> cm -> m 
....................    if(distance > 99){ 
01A4:  MOVF   07,F
01A6:  BNZ   01AE
01A8:  MOVF   06,W
01AA:  SUBLW  63
01AC:  BC    01CC
....................       distance = distance / 10; 
01AE:  MOVFF  07,12
01B2:  MOVFF  06,11
01B6:  CLRF   14
01B8:  MOVLW  0A
01BA:  MOVWF  13
01BC:  RCALL  0016
01BE:  MOVFF  02,07
01C2:  MOVFF  01,06
....................       output_high(dot); 
01C6:  BCF    F96.2
01C8:  BSF    F8D.2
....................    } 
01CA:  BRA    01D0
....................    else { 
....................       output_low(dot); 
01CC:  BCF    F96.2
01CE:  BCF    F8D.2
....................    } 
....................     
....................    // afichage sur 7seg de la distance 
....................    output_b(outputValueParser(distance)); 
01D0:  MOVFF  07,0F
01D4:  MOVFF  06,0E
01D8:  BRA    0080
01DA:  CLRF   F93
01DC:  MOVFF  01,F8A
....................     
....................    // attente pour éviter spam  
....................    delay_ms(500); 
01E0:  MOVLW  02
01E2:  MOVWF  0E
01E4:  MOVLW  FA
01E6:  MOVWF  0F
01E8:  BRA    00FE
01EA:  DECFSZ 0E,F
01EC:  BRA    01E4
01EE:  BRA    014E
....................    } 
....................  
.................... } 
....................  
01F0:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   PUT NOBROWNOUT BORV25 NOWDT WDT128
   Word  3: 0000  
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
