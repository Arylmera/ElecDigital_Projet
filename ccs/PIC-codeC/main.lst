CCS PCH C Compiler, Version 5.094d, 1               03-mai-20 17:03
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   D:\Utilisateurs\Arnaud\Documents\GitHub\ElecDigital_Projet\ccs\PIC-codeC\main.lst

               ROM used:   2104 bytes (6%)
                           Largest free fragment is 30660
               RAM used:   49 (3%) at main() level
                           64 (4%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 31

0000:  GOTO   05CC
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   00C2
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <main.h>
.................... #include <18F458.h>
.................... //////////// Standard Header file for the PIC18F458 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F458
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 28,0C
00C0:  DATA 01,06
*
00F6:  DATA 20,50
00F8:  DATA 72,6F
00FA:  DATA 6A,65
00FC:  DATA 74,20
00FE:  DATA 45,6C
0100:  DATA 65,63
0102:  DATA 74,72
0104:  DATA 6F,6E
0106:  DATA 69,71
0108:  DATA 75,65
010A:  DATA 20,00
010C:  DATA 20,32
010E:  DATA 30,32
0110:  DATA 30,20
0112:  DATA 47,72
0114:  DATA 6F,75
0116:  DATA 70,65
0118:  DATA 20,33
011A:  DATA 20,00
011C:  DATA 20,4D
011E:  DATA 69,6E
0120:  DATA 56,61
0122:  DATA 6C,3A
0124:  DATA 20,00
0126:  DATA 20,44
0128:  DATA 69,73
012A:  DATA 74,61
012C:  DATA 6E,63
012E:  DATA 65,3A
0130:  DATA 20,00
*
026A:  ADDWF  FE8,W
026C:  CLRF   FF7
026E:  RLCF   FF7,F
0270:  ADDLW  85
0272:  MOVWF  FF6
0274:  MOVLW  02
0276:  ADDWFC FF7,F
0278:  TBLRD*-
027A:  MOVF   FF5,W
027C:  MOVWF  FFA
027E:  TBLRD*
0280:  MOVF   FF5,W
0282:  MOVWF  FF9
0284:  DATA 44,02
0286:  DATA 4A,02
0288:  DATA 50,02
028A:  DATA 56,02
*
02D4:  TBLRD*+
02D6:  MOVF   FF5,F
02D8:  BZ    02F2
02DA:  MOVFF  FF6,2F
02DE:  MOVFF  FF7,30
02E2:  MOVFF  FF5,35
02E6:  RCALL  028C
02E8:  MOVFF  2F,FF6
02EC:  MOVFF  30,FF7
02F0:  BRA    02D4
02F2:  RETURN 0
*
0358:  CLRF   01
035A:  CLRF   02
035C:  CLRF   00
035E:  CLRF   03
0360:  MOVF   35,W
0362:  BNZ   0368
0364:  MOVF   34,W
0366:  BZ    0398
0368:  MOVLW  10
036A:  MOVWF  36
036C:  BCF    FD8.0
036E:  RLCF   32,F
0370:  RLCF   33,F
0372:  RLCF   00,F
0374:  RLCF   03,F
0376:  MOVF   35,W
0378:  SUBWF  03,W
037A:  BNZ   0380
037C:  MOVF   34,W
037E:  SUBWF  00,W
0380:  BNC   0390
0382:  MOVF   34,W
0384:  SUBWF  00,F
0386:  BTFSS  FD8.0
0388:  DECF   03,F
038A:  MOVF   35,W
038C:  SUBWF  03,F
038E:  BSF    FD8.0
0390:  RLCF   01,F
0392:  RLCF   02,F
0394:  DECFSZ 36,F
0396:  BRA    036C
0398:  RETURN 0
039A:  MOVFF  FEA,37
039E:  MOVFF  FE9,36
03A2:  BTFSS  30.7
03A4:  BRA    03B6
03A6:  BSF    36.7
03A8:  BTFSS  36.4
03AA:  INCF   36,F
03AC:  COMF   2F,F
03AE:  COMF   30,F
03B0:  INCF   2F,F
03B2:  BTFSC  FD8.2
03B4:  INCF   30,F
03B6:  SWAPF  30,W
03B8:  IORLW  F0
03BA:  MOVWF  32
03BC:  ADDWF  32,F
03BE:  ADDLW  E2
03C0:  MOVWF  33
03C2:  ADDLW  32
03C4:  MOVWF  35
03C6:  MOVF   30,W
03C8:  ANDLW  0F
03CA:  ADDWF  33,F
03CC:  ADDWF  33,F
03CE:  ADDWF  35,F
03D0:  ADDLW  E9
03D2:  MOVWF  34
03D4:  ADDWF  34,F
03D6:  ADDWF  34,F
03D8:  SWAPF  2F,W
03DA:  ANDLW  0F
03DC:  ADDWF  34,F
03DE:  ADDWF  35,F
03E0:  RLCF   34,F
03E2:  RLCF   35,F
03E4:  COMF   35,F
03E6:  RLCF   35,F
03E8:  MOVF   2F,W
03EA:  ANDLW  0F
03EC:  ADDWF  35,F
03EE:  RLCF   32,F
03F0:  MOVLW  07
03F2:  MOVWF  31
03F4:  MOVLW  0A
03F6:  DECF   34,F
03F8:  ADDWF  35,F
03FA:  BNC   03F6
03FC:  DECF   33,F
03FE:  ADDWF  34,F
0400:  BNC   03FC
0402:  DECF   32,F
0404:  ADDWF  33,F
0406:  BNC   0402
0408:  DECF   31,F
040A:  ADDWF  32,F
040C:  BNC   0408
040E:  CLRF   FEA
0410:  MOVLW  31
0412:  MOVWF  FE9
0414:  MOVLW  07
0416:  ANDWF  36,W
0418:  BCF    36.6
041A:  MOVF   FED,F
041C:  ANDWF  36,W
041E:  BNZ   042E
0420:  BTFSC  36.4
0422:  MOVF   FEE,F
0424:  BTFSC  36.4
0426:  BRA    042E
0428:  MOVLW  20
042A:  MOVWF  00
042C:  BRA    046E
042E:  ADDWF  FE9,F
0430:  MOVLW  00
0432:  ADDWFC FEA,F
0434:  MOVF   FE9,W
0436:  SUBLW  35
0438:  BNZ   0440
043A:  MOVF   FEA,F
043C:  BNZ   0440
043E:  BSF    36.6
0440:  MOVF   FEF,W
0442:  MOVWF  00
0444:  BNZ   0456
0446:  BTFSC  36.6
0448:  BRA    0456
044A:  BTFSC  36.4
044C:  BRA    0476
044E:  BTFSC  36.3
0450:  BRA    0456
0452:  MOVLW  20
0454:  BRA    046C
0456:  BTFSS  36.7
0458:  BRA    0466
045A:  MOVLW  2D
045C:  MOVWF  00
045E:  MOVF   FED,W
0460:  BCF    36.6
0462:  BCF    36.7
0464:  BRA    046E
0466:  BSF    36.3
0468:  BCF    36.4
046A:  MOVLW  30
046C:  ADDWF  00,F
046E:  MOVF   00,W
0470:  BTFSS  F9E.4
0472:  BRA    0470
0474:  MOVWF  FAD
0476:  MOVF   FEE,W
0478:  BTFSS  36.6
047A:  BRA    0434
047C:  GOTO   067A (RETURN)
0480:  MOVF   36,W
0482:  CLRF   01
0484:  SUBWF  35,W
0486:  BC    048E
0488:  MOVFF  35,00
048C:  BRA    04A6
048E:  CLRF   00
0490:  MOVLW  08
0492:  MOVWF  37
0494:  RLCF   35,F
0496:  RLCF   00,F
0498:  MOVF   36,W
049A:  SUBWF  00,W
049C:  BTFSC  FD8.0
049E:  MOVWF  00
04A0:  RLCF   01,F
04A2:  DECFSZ 37,F
04A4:  BRA    0494
04A6:  RETURN 0
04A8:  MOVLW  20
04AA:  BTFSS  30.4
04AC:  MOVLW  30
04AE:  MOVWF  31
04B0:  MOVFF  2F,00
04B4:  BTFSS  2F.7
04B6:  BRA    04C8
04B8:  COMF   00,F
04BA:  INCF   00,F
04BC:  MOVFF  00,2F
04C0:  MOVLW  2D
04C2:  MOVWF  31
04C4:  BSF    30.7
04C6:  BSF    30.0
04C8:  MOVF   01,W
04CA:  MOVFF  2F,35
04CE:  MOVLW  64
04D0:  MOVWF  36
04D2:  RCALL  0480
04D4:  MOVFF  00,2F
04D8:  MOVLW  30
04DA:  ADDWF  01,W
04DC:  MOVWF  32
04DE:  MOVFF  2F,35
04E2:  MOVLW  0A
04E4:  MOVWF  36
04E6:  RCALL  0480
04E8:  MOVLW  30
04EA:  ADDWF  00,W
04EC:  MOVWF  34
04EE:  MOVLW  30
04F0:  ADDWF  01,W
04F2:  MOVWF  33
04F4:  MOVFF  31,00
04F8:  MOVLW  30
04FA:  SUBWF  32,W
04FC:  BZ    0506
04FE:  BSF    30.1
0500:  BTFSC  30.7
0502:  BSF    30.2
0504:  BRA    052A
0506:  MOVFF  31,32
050A:  MOVLW  20
050C:  MOVWF  31
050E:  MOVLW  30
0510:  SUBWF  33,W
0512:  BZ    051C
0514:  BSF    30.0
0516:  BTFSC  30.7
0518:  BSF    30.1
051A:  BRA    052A
051C:  BTFSS  FD8.2
051E:  BSF    30.0
0520:  BNZ   052A
0522:  MOVFF  32,33
0526:  MOVLW  20
0528:  MOVWF  32
052A:  BTFSC  30.2
052C:  BRA    0538
052E:  BTFSC  30.1
0530:  BRA    053E
0532:  BTFSC  30.0
0534:  BRA    0544
0536:  BRA    054A
0538:  MOVFF  31,35
053C:  RCALL  028C
053E:  MOVFF  32,35
0542:  RCALL  028C
0544:  MOVFF  33,35
0548:  RCALL  028C
054A:  MOVFF  34,35
054E:  RCALL  028C
0550:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=16
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... 
.................... #use delay(crystal=20MHz)
*
0132:  CLRF   FEA
0134:  MOVLW  36
0136:  MOVWF  FE9
0138:  MOVF   FEF,W
013A:  BZ    0156
013C:  MOVLW  06
013E:  MOVWF  01
0140:  CLRF   00
0142:  DECFSZ 00,F
0144:  BRA    0142
0146:  DECFSZ 01,F
0148:  BRA    0140
014A:  MOVLW  7B
014C:  MOVWF  00
014E:  DECFSZ 00,F
0150:  BRA    014E
0152:  DECFSZ FEF,F
0154:  BRA    013C
0156:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=0,rcv=0,bits=8,stream=PORT1)
.................... 
.................... #define LED PIN_None
.................... #define DELAY 1000
.................... 
.................... 
.................... 
.................... #include "LCD420.c"
.................... ///////////////////////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD420.C                                                  ////
.................... ////            Driver for common 4x20 LCD modules  (Fonction de haut niveau )             ////
.................... ////                                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.                               ////
.................... ////                                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.                         ////
.................... ////                     The following have special meaning:                               ////
.................... ////                      \f  Clear display                                                ////
.................... ////                      \n  Go to start of second line                                   ////
.................... ////                      \b  Move back one position                                       ////
.................... ////                                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1 -> 20,4)                ////
.................... ////                                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD                             ////
.................... ////                                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,1997 Custom Computer Services                               ////
.................... //// This source code may only be used by licensed users of the CCS C                      ////
.................... //// compiler.  This source code may only be distributed to other                          ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction                     ////
.................... //// or distribution is permitted without written permission.                              ////
.................... //// Derivative programs created using this software in object code                        ////
.................... //// form are not restricted in any way.                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // As defined in the following structure the pin connection is as follows:
.................... //     B0  enable
.................... //     B1  rs
.................... //     B2  rw
.................... //     B4  D4
.................... //     B5  D5
.................... //     B6  D6
.................... //     B7  D7
.................... //
.................... //   LCD pins D0-D3 are not used and PIC B3 is not used.
.................... 
.................... struct lcd_pin_map {                 // This structure is overlayed ( Mettre dans l'ordre de poid faible ? fort )
....................            int     data : 4;         // be pin B0.
....................            BOOLEAN rs;               // access to the LCD pins.
....................            BOOLEAN rw;               // The bits are allocated from
....................            BOOLEAN enable;           // on to an I/O port to gain
....................            BOOLEAN unused;           // low order up.  ENABLE will
.................... 
....................         } lcd;
.................... 
.................... #byte lcd = 0xF83                        // This puts the entire structure ( se trouve ? la page 47 du datasheet dans "SPECIAL FUNCTION REGISTER MAP" )
....................                                          // on to port B (at address 6)
.................... 
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines
.................... 
.................... 
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6};
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
.................... 
.................... 
....................                              // The following are used for setting
....................                              // the I/O port direction register.
.................... 
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out
.................... struct lcd_pin_map const LCD_READ = {15,0,0,0,0}; // For read mode data pins are in  ( 15 car les 4 bits du lcd doivent etre ? l'?tat haut et du cot? gauche car d?plac? en premiere ligne dans struct )
.................... 
.................... 
.................... BYTE lcdline;
.................... 
.................... BYTE lcd_read_byte() {  // Fonction de bas niveau
....................       BYTE low,high;
.................... 
....................       set_tris_d(LCD_READ);
*
0176:  MOVLW  0F
0178:  MOVWF  F95
....................       lcd.rw = 1;
017A:  BSF    F83.5
....................       delay_cycles(1);
017C:  NOP   
....................       lcd.enable = 1;
017E:  BSF    F83.6
....................       delay_cycles(1);
0180:  NOP   
....................       high = lcd.data;
0182:  MOVF   F83,W
0184:  ANDLW  0F
0186:  MOVWF  3C
....................       lcd.enable = 0;
0188:  BCF    F83.6
....................       delay_cycles(1);
018A:  NOP   
....................       lcd.enable = 1;
018C:  BSF    F83.6
....................       delay_us(1);
018E:  BRA    0190
0190:  BRA    0192
0192:  NOP   
....................       low = lcd.data;
0194:  MOVF   F83,W
0196:  ANDLW  0F
0198:  MOVWF  3B
....................       lcd.enable = 0;
019A:  BCF    F83.6
....................       set_tris_d(LCD_WRITE);
019C:  MOVLW  00
019E:  MOVWF  F95
....................       return( (high<<4) | low);
01A0:  SWAPF  3C,W
01A2:  MOVWF  00
01A4:  MOVLW  F0
01A6:  ANDWF  00,F
01A8:  MOVF   00,W
01AA:  IORWF  3B,W
01AC:  MOVWF  01
01AE:  GOTO   01B6 (RETURN)
.................... }
.................... 
.................... 
.................... void lcd_send_nibble( BYTE n ) {  // Fonction de bas niveau
....................       lcd.data = n;
*
0158:  MOVF   3C,W
015A:  ANDLW  0F
015C:  MOVWF  00
015E:  MOVLW  F0
0160:  ANDWF  F83,W
0162:  IORWF  00,W
0164:  MOVWF  F83
....................       delay_cycles(1);
0166:  NOP   
....................       lcd.enable = 1;
0168:  BSF    F83.6
....................       delay_us(2);
016A:  MOVLW  03
016C:  MOVWF  00
016E:  DECFSZ 00,F
0170:  BRA    016E
....................       lcd.enable = 0;
0172:  BCF    F83.6
0174:  RETURN 0
.................... }
.................... 
.................... 
.................... void lcd_send_byte( BYTE address, BYTE n ) {  // Fonction de bas niveau
.................... 
....................       lcd.rs = 0;
*
01B2:  BCF    F83.4
....................       while ( bit_test(lcd_read_byte(),7) ) ;
01B4:  BRA    0176
01B6:  MOVFF  01,3B
01BA:  BTFSC  01.7
01BC:  BRA    01B4
....................       lcd.rs = address;
01BE:  BTFSS  39.0
01C0:  BCF    F83.4
01C2:  BTFSC  39.0
01C4:  BSF    F83.4
....................       delay_cycles(1);
01C6:  NOP   
....................       lcd.rw = 0;
01C8:  BCF    F83.5
....................       delay_cycles(1);
01CA:  NOP   
....................       lcd.enable = 0;
01CC:  BCF    F83.6
....................       lcd_send_nibble(n >> 4);
01CE:  SWAPF  3A,W
01D0:  MOVWF  3B
01D2:  MOVLW  0F
01D4:  ANDWF  3B,F
01D6:  MOVFF  3B,3C
01DA:  RCALL  0158
....................       lcd_send_nibble(n & 0xf);
01DC:  MOVF   3A,W
01DE:  ANDLW  0F
01E0:  MOVWF  3B
01E2:  MOVWF  3C
01E4:  RCALL  0158
01E6:  RETURN 0
.................... }
.................... 
.................... 
.................... void lcd_init() {
....................     BYTE i;
.................... 
....................     set_tris_d(LCD_WRITE);
01E8:  MOVLW  00
01EA:  MOVWF  F95
....................     lcd.rs = 0;
01EC:  BCF    F83.4
....................     lcd.rw = 0;
01EE:  BCF    F83.5
....................     lcd.enable = 0;
01F0:  BCF    F83.6
....................     delay_ms(15);
01F2:  MOVLW  0F
01F4:  MOVWF  36
01F6:  RCALL  0132
....................     for(i=1;i<=3;++i) {
01F8:  MOVLW  01
01FA:  MOVWF  2F
01FC:  MOVF   2F,W
01FE:  SUBLW  03
0200:  BNC   0212
....................        lcd_send_nibble(3);
0202:  MOVLW  03
0204:  MOVWF  3C
0206:  RCALL  0158
....................        delay_ms(5);
0208:  MOVLW  05
020A:  MOVWF  36
020C:  RCALL  0132
020E:  INCF   2F,F
0210:  BRA    01FC
....................     }
....................     lcd_send_nibble(2);
0212:  MOVLW  02
0214:  MOVWF  3C
0216:  RCALL  0158
....................     for(i=0;i<=3;++i)
0218:  CLRF   2F
021A:  MOVF   2F,W
021C:  SUBLW  03
021E:  BNC   0232
....................        lcd_send_byte(0, LCD_INIT_STRING[i]);
0220:  CLRF   03
0222:  MOVF   2F,W
0224:  RCALL  00AE
0226:  MOVWF  30
0228:  CLRF   39
022A:  MOVWF  3A
022C:  RCALL  01B2
022E:  INCF   2F,F
0230:  BRA    021A
0232:  GOTO   0628 (RETURN)
.................... }
.................... 
.................... 
.................... void lcd_gotoxy( BYTE x, BYTE y) {
....................    BYTE address;
.................... 
....................    switch(y) {
0236:  MOVLW  01
0238:  SUBWF  37,W
023A:  ADDLW  FC
023C:  BC    025A
023E:  ADDLW  04
0240:  GOTO   026A
....................      case 1 : address=0x80;break;
0244:  MOVLW  80
0246:  MOVWF  38
0248:  BRA    025A
....................      case 2 : address=0xc0;break;
024A:  MOVLW  C0
024C:  MOVWF  38
024E:  BRA    025A
....................      case 3 : address=0x94;break;
0250:  MOVLW  94
0252:  MOVWF  38
0254:  BRA    025A
....................      case 4 : address=0xd4;break;
0256:  MOVLW  D4
0258:  MOVWF  38
....................    }
....................    address+=x-1;
025A:  MOVLW  01
025C:  SUBWF  36,W
025E:  ADDWF  38,F
....................    lcd_send_byte(0,address);
0260:  CLRF   39
0262:  MOVFF  38,3A
0266:  RCALL  01B2
0268:  RETURN 0
.................... }
.................... 
.................... void lcd_putc( char c) {
....................    switch (c) {
*
028C:  MOVF   35,W
028E:  XORLW  0C
0290:  BZ    029C
0292:  XORLW  06
0294:  BZ    02B0
0296:  XORLW  02
0298:  BZ    02BE
029A:  BRA    02C8
....................      case '\f'   : lcd_send_byte(0,1);
029C:  CLRF   39
029E:  MOVLW  01
02A0:  MOVWF  3A
02A2:  RCALL  01B2
....................                    lcdline=1;
02A4:  MOVLW  01
02A6:  MOVWF  19
....................                    delay_ms(2);
02A8:  MOVLW  02
02AA:  MOVWF  36
02AC:  RCALL  0132
....................                                            break;
02AE:  BRA    02D2
....................      case '\n'   : lcd_gotoxy(1,++lcdline);        break;
02B0:  INCF   19,F
02B2:  MOVLW  01
02B4:  MOVWF  36
02B6:  MOVFF  19,37
02BA:  RCALL  0236
02BC:  BRA    02D2
....................      case '\b'   : lcd_send_byte(0,0x10);  break;
02BE:  CLRF   39
02C0:  MOVLW  10
02C2:  MOVWF  3A
02C4:  RCALL  01B2
02C6:  BRA    02D2
....................      default     : lcd_send_byte(1,c);     break;
02C8:  MOVLW  01
02CA:  MOVWF  39
02CC:  MOVFF  35,3A
02D0:  RCALL  01B2
....................    }
02D2:  RETURN 0
.................... }
.................... 
.................... char lcd_getc( BYTE x, BYTE y) {
....................    char value;
.................... 
....................     lcd_gotoxy(x,y);
....................     lcd.rs=1;
....................     value = lcd_read_byte();
....................     lcd.rs=0;
....................     return(value);
.................... }
.................... 
.................... 
.................... #use fast_io(C)
.................... 
.................... #use rs232(baud=9600, parity=N, xmit=PIN_C6, rcv=PIN_C7)
.................... 
.................... #define trigger pin_C0
.................... #define echo pin_C1
.................... #define dot pin_E2
.................... #define RX pin_C7
.................... #define TX pin_C6
.................... #define GREEN pin_E0
.................... #define RED pin_E1
.................... 
.................... #int_TIMER1
.................... 
.................... int16 time, distance, x, i, minVal;
.................... int flag=0;
.................... char buffer[4];
.................... int j=0;
.................... int8 c,d,u;
.................... 
.................... #int_RDA
.................... void RDA_isr(void) {
.................... buffer[j]=getc();
*
00C2:  CLRF   03
00C4:  MOVF   29,W
00C6:  ADDLW  25
00C8:  MOVWF  FE9
00CA:  MOVLW  00
00CC:  ADDWFC 03,W
00CE:  MOVWF  FEA
00D0:  BTFSS  F9E.5
00D2:  BRA    00D0
00D4:  MOVFF  FAE,FEF
....................   if(buffer[0]=='!' && flag==0) {
00D8:  MOVF   25,W
00DA:  SUBLW  21
00DC:  BNZ   00F0
00DE:  MOVF   24,F
00E0:  BNZ   00F0
....................     j++;
00E2:  INCF   29,F
....................     if(j>=4) {
00E4:  MOVF   29,W
00E6:  SUBLW  03
00E8:  BC    00F0
....................       j=0;
00EA:  CLRF   29
....................       flag=1;
00EC:  MOVLW  01
00EE:  MOVWF  24
....................     }
....................   }
00F0:  BCF    F9E.5
00F2:  GOTO   0060
.................... }
.................... 
.................... /*
.................... * transofmation de la valeur en valeur base 16
.................... */
.................... int16 outputValueParser(int16 value){
*
0552:  CLRF   31
....................    int output = 0;
....................    if (value < 10) { output = value;}
0554:  MOVF   30,F
0556:  BNZ   0564
0558:  MOVF   2F,W
055A:  SUBLW  09
055C:  BNC   0564
055E:  MOVFF  2F,31
0562:  BRA    05C2
....................    else {
....................     x = value;
0564:  MOVFF  30,1F
0568:  MOVFF  2F,1E
....................     x = x % 10;
056C:  MOVFF  1F,33
0570:  MOVFF  1E,32
0574:  CLRF   35
0576:  MOVLW  0A
0578:  MOVWF  34
057A:  RCALL  0358
057C:  MOVFF  00,1E
0580:  MOVFF  03,1F
....................     i = value;
0584:  MOVFF  30,21
0588:  MOVFF  2F,20
....................     i = i/10;
058C:  MOVFF  21,33
0590:  MOVFF  20,32
0594:  CLRF   35
0596:  MOVLW  0A
0598:  MOVWF  34
059A:  RCALL  0358
059C:  MOVFF  02,21
05A0:  MOVFF  01,20
.................... 
....................     output = x + i*16;
05A4:  RLCF   20,W
05A6:  MOVWF  02
05A8:  RLCF   21,W
05AA:  MOVWF  03
05AC:  RLCF   02,F
05AE:  RLCF   03,F
05B0:  RLCF   02,F
05B2:  RLCF   03,F
05B4:  RLCF   02,F
05B6:  RLCF   03,F
05B8:  MOVLW  F0
05BA:  ANDWF  02,F
05BC:  MOVF   02,W
05BE:  ADDWF  1E,W
05C0:  MOVWF  31
....................    }
....................    return output;
05C2:  MOVFF  31,01
05C6:  CLRF   02
05C8:  GOTO   0824 (RETURN)
.................... }
.................... 
.................... /*
.................... * trigger de la sonde
.................... */
.................... void triggerSonde(){
....................    output_high(trigger);
*
0346:  BSF    F8B.0
....................    delay_us(10);
0348:  MOVLW  10
034A:  MOVWF  00
034C:  DECFSZ 00,F
034E:  BRA    034C
0350:  NOP   
....................    output_low(trigger);
0352:  BCF    F8B.0
0354:  GOTO   0636 (RETURN)
.................... }
.................... 
.................... /*
.................... * Fonctione d'initalisation du LCD
.................... */
.................... void init_lcd(){
....................    delay_ms(500);
*
02F4:  MOVLW  02
02F6:  MOVWF  2F
02F8:  MOVLW  FA
02FA:  MOVWF  36
02FC:  RCALL  0132
02FE:  DECFSZ 2F,F
0300:  BRA    02F8
....................    lcd_putc('\f');
0302:  MOVLW  0C
0304:  MOVWF  35
0306:  RCALL  028C
....................    lcd_gotoxy(1,1);
0308:  MOVLW  01
030A:  MOVWF  36
030C:  MOVWF  37
030E:  RCALL  0236
....................    printf(lcd_putc," Projet Electronique ");
0310:  MOVLW  F6
0312:  MOVWF  FF6
0314:  MOVLW  00
0316:  MOVWF  FF7
0318:  RCALL  02D4
....................    lcd_gotoxy(1,3);
031A:  MOVLW  01
031C:  MOVWF  36
031E:  MOVLW  03
0320:  MOVWF  37
0322:  RCALL  0236
....................    printf(lcd_putc," 2020 Groupe 3 ");
0324:  MOVLW  0C
0326:  MOVWF  FF6
0328:  MOVLW  01
032A:  MOVWF  FF7
032C:  RCALL  02D4
....................    delay_ms(1000);
032E:  MOVLW  04
0330:  MOVWF  2F
0332:  MOVLW  FA
0334:  MOVWF  36
0336:  RCALL  0132
0338:  DECFSZ 2F,F
033A:  BRA    0332
....................    lcd_putc('\f');
033C:  MOVLW  0C
033E:  MOVWF  35
0340:  RCALL  028C
0342:  GOTO   062A (RETURN)
.................... }
.................... 
.................... 
.................... /*
.................... * fonction principale
.................... */
.................... void main()
*
05CC:  CLRF   FF8
05CE:  BCF    FD0.7
05D0:  BSF    07.7
05D2:  BSF    00.0
05D4:  MOVLW  81
05D6:  MOVWF  FAF
05D8:  MOVLW  A6
05DA:  MOVWF  FAC
05DC:  MOVLW  90
05DE:  MOVWF  FAB
05E0:  CLRF   24
05E2:  CLRF   29
05E4:  CLRF   2E
05E6:  CLRF   2D
05E8:  BSF    FC1.0
05EA:  BSF    FC1.1
05EC:  BSF    FC1.2
05EE:  BCF    FC1.3
05F0:  MOVLW  07
05F2:  MOVWF  FB4
.................... {
....................    setup_low_volt_detect(FALSE);
05F4:  CLRF   FD2
....................    set_tris_c(0b01000010); // set RC1 as input (ECHO)
05F6:  MOVLW  42
05F8:  MOVWF  F94
.................... 
....................    setup_spi(FALSE);
05FA:  CLRF   FC6
....................    setup_wdt(WDT_OFF);
05FC:  BCF    FD1.0
....................    setup_timer_1( T1_INTERNAL | T1_DIV_BY_1  );
05FE:  MOVLW  85
0600:  MOVWF  FCD
....................    setup_comparator(NC_NC_NC_NC);
0602:  MOVLW  07
0604:  MOVWF  FB4
0606:  MOVF   F95,W
0608:  MOVWF  F95
060A:  MOVF   F96,W
060C:  MOVWF  F96
060E:  MOVLW  10
0610:  MOVWF  00
0612:  DECFSZ 00,F
0614:  BRA    0612
0616:  NOP   
0618:  MOVF   FB4,W
061A:  BCF    FA1.6
....................    setup_vref(FALSE);
061C:  CLRF   FB5
.................... 
....................    enable_interrupts(INT_RDA); // interuption sur r�ception port RS232
061E:  BSF    F9D.5
....................    enable_interrupts(GLOBAL);
0620:  MOVLW  C0
0622:  IORWF  FF2,F
....................    setup_oscillator(False);
0624:  CLRF   FD3
.................... 
....................    lcd_init();
0626:  BRA    01E8
....................    init_lcd();
0628:  BRA    02F4
.................... 
....................    while(true)
....................    {
.................... 
....................    // setup des valeurs
....................    time = 0;
062A:  CLRF   1B
062C:  CLRF   1A
.................... 
....................    // recuperation minValue envoye par JAVA
....................    minVal = 100;
062E:  CLRF   23
0630:  MOVLW  64
0632:  MOVWF  22
.................... 
....................    // d�clanchement de la sonde
....................    triggerSonde();
0634:  BRA    0346
.................... 
....................    // recuperation valeur temps de la sonde
....................    while(input(echo) == 0){} // attente debut
0636:  BTFSS  F82.1
0638:  BRA    0636
....................    set_timer1(0);
063A:  CLRF   FCF
063C:  CLRF   FCE
....................    while(input(echo) == 1){} // attente fin
063E:  BTFSC  F82.1
0640:  BRA    063E
....................    time = get_timer1();
0642:  MOVF   FCE,W
0644:  MOVWF  1A
0646:  MOVFF  FCF,1B
.................... 
....................    // temps => distance
....................    distance = time/285;
064A:  MOVFF  1B,33
064E:  MOVFF  1A,32
0652:  MOVLW  01
0654:  MOVWF  35
0656:  MOVLW  1D
0658:  MOVWF  34
065A:  RCALL  0358
065C:  MOVFF  02,1D
0660:  MOVFF  01,1C
.................... 
....................    // envoie distance ici java
....................    printf(" %ld", distance);
0664:  MOVLW  20
0666:  BTFSS  F9E.4
0668:  BRA    0666
066A:  MOVWF  FAD
066C:  MOVLW  10
066E:  MOVWF  FE9
0670:  MOVFF  1D,30
0674:  MOVFF  1C,2F
0678:  BRA    039A
....................    printf("\n");
067A:  MOVLW  0A
067C:  BTFSS  F9E.4
067E:  BRA    067C
0680:  MOVWF  FAD
.................... 
....................    // si donn�es recu depuis java sur RS232 > interuption INT_RSA
....................    if(flag==1){
0682:  DECFSZ 24,W
0684:  BRA    06B0
....................      flag=0;
0686:  CLRF   24
....................      c=buffer[1]-48;
0688:  MOVLW  30
068A:  SUBWF  26,W
068C:  MOVWF  2A
....................      d=buffer[2]-48;
068E:  MOVLW  30
0690:  SUBWF  27,W
0692:  MOVWF  2B
....................      u=buffer[3]-48;
0694:  MOVLW  30
0696:  SUBWF  28,W
0698:  MOVWF  2C
....................      minVal=(int16) (c*100+d*10+u);
069A:  MOVF   2A,W
069C:  MULLW  64
069E:  MOVFF  FF3,2F
06A2:  MOVF   2B,W
06A4:  MULLW  0A
06A6:  MOVF   FF3,W
06A8:  ADDWF  2F,W
06AA:  ADDWF  2C,W
06AC:  CLRF   23
06AE:  MOVWF  22
....................    }
.................... 
....................    // cr�ation valeurs LCD MINvalue
....................    c = minVal/100;
06B0:  MOVFF  23,33
06B4:  MOVFF  22,32
06B8:  CLRF   35
06BA:  MOVLW  64
06BC:  MOVWF  34
06BE:  RCALL  0358
06C0:  MOVFF  01,2A
....................    d = (minVal-(c*100))/10;
06C4:  MOVF   2A,W
06C6:  MULLW  64
06C8:  MOVF   FF3,W
06CA:  SUBWF  22,W
06CC:  MOVWF  2F
06CE:  MOVLW  00
06D0:  SUBWFB 23,W
06D2:  MOVWF  30
06D4:  MOVWF  33
06D6:  MOVFF  2F,32
06DA:  CLRF   35
06DC:  MOVLW  0A
06DE:  MOVWF  34
06E0:  RCALL  0358
06E2:  MOVFF  01,2B
....................    u = (minVal-(c*100))-(d*10);
06E6:  MOVF   2A,W
06E8:  MULLW  64
06EA:  MOVF   FF3,W
06EC:  SUBWF  22,W
06EE:  MOVWF  2F
06F0:  MOVLW  00
06F2:  SUBWFB 23,W
06F4:  MOVF   2B,W
06F6:  MULLW  0A
06F8:  MOVF   FF3,W
06FA:  SUBWF  2F,W
06FC:  MOVWF  2C
....................    // Affichage MinValue LCD
....................    lcd_gotoxy(3,1);
06FE:  MOVLW  03
0700:  MOVWF  36
0702:  MOVLW  01
0704:  MOVWF  37
0706:  RCALL  0236
....................    printf(lcd_putc, " MinVal: ");
0708:  MOVLW  1C
070A:  MOVWF  FF6
070C:  MOVLW  01
070E:  MOVWF  FF7
0710:  RCALL  02D4
....................    printf(lcd_putc, "%d", c);
0712:  MOVFF  2A,2F
0716:  MOVLW  18
0718:  MOVWF  30
071A:  RCALL  04A8
....................    printf(lcd_putc, "%d", d);
071C:  MOVFF  2B,2F
0720:  MOVLW  18
0722:  MOVWF  30
0724:  RCALL  04A8
....................    printf(lcd_putc, "%d", u);
0726:  MOVFF  2C,2F
072A:  MOVLW  18
072C:  MOVWF  30
072E:  RCALL  04A8
....................    // cr�eation valeurs Distance LCD
....................    c = distance/100;
0730:  MOVFF  1D,33
0734:  MOVFF  1C,32
0738:  CLRF   35
073A:  MOVLW  64
073C:  MOVWF  34
073E:  RCALL  0358
0740:  MOVFF  01,2A
....................    d = (distance-(c*100))/10;
0744:  MOVF   2A,W
0746:  MULLW  64
0748:  MOVF   FF3,W
074A:  SUBWF  1C,W
074C:  MOVWF  2F
074E:  MOVLW  00
0750:  SUBWFB 1D,W
0752:  MOVWF  30
0754:  MOVWF  33
0756:  MOVFF  2F,32
075A:  CLRF   35
075C:  MOVLW  0A
075E:  MOVWF  34
0760:  RCALL  0358
0762:  MOVFF  01,2B
....................    u = (distance-(c*100))-(d*10);
0766:  MOVF   2A,W
0768:  MULLW  64
076A:  MOVF   FF3,W
076C:  SUBWF  1C,W
076E:  MOVWF  2F
0770:  MOVLW  00
0772:  SUBWFB 1D,W
0774:  MOVF   2B,W
0776:  MULLW  0A
0778:  MOVF   FF3,W
077A:  SUBWF  2F,W
077C:  MOVWF  2C
....................    // affichage distance LCD
....................    lcd_gotoxy(3,3);
077E:  MOVLW  03
0780:  MOVWF  36
0782:  MOVWF  37
0784:  RCALL  0236
....................    printf(lcd_putc, " Distance: ");
0786:  MOVLW  26
0788:  MOVWF  FF6
078A:  MOVLW  01
078C:  MOVWF  FF7
078E:  RCALL  02D4
....................    printf(lcd_putc, "%d", c);
0790:  MOVFF  2A,2F
0794:  MOVLW  18
0796:  MOVWF  30
0798:  RCALL  04A8
....................    printf(lcd_putc, "%d", d);
079A:  MOVFF  2B,2F
079E:  MOVLW  18
07A0:  MOVWF  30
07A2:  RCALL  04A8
....................    printf(lcd_putc, "%d", u);
07A4:  MOVFF  2C,2F
07A8:  MOVLW  18
07AA:  MOVWF  30
07AC:  RCALL  04A8
.................... 
....................    // v�rification borne minVal
....................    if (distance < minVal){
07AE:  MOVF   1D,W
07B0:  SUBWF  23,W
07B2:  BNC   07D6
07B4:  BNZ   07BC
07B6:  MOVF   22,W
07B8:  SUBWF  1C,W
07BA:  BC    07D6
....................       // allumer red => trop proche
....................       printf("1\n");
07BC:  MOVLW  31
07BE:  BTFSS  F9E.4
07C0:  BRA    07BE
07C2:  MOVWF  FAD
07C4:  MOVLW  0A
07C6:  BTFSS  F9E.4
07C8:  BRA    07C6
07CA:  MOVWF  FAD
....................       output_high(RED);
07CC:  BCF    F96.1
07CE:  BSF    F8D.1
....................       output_low(GREEN);
07D0:  BCF    F96.0
07D2:  BCF    F8D.0
....................    }
07D4:  BRA    07EE
....................    else {
....................       // allumer green => OK
....................       printf("2\n");
07D6:  MOVLW  32
07D8:  BTFSS  F9E.4
07DA:  BRA    07D8
07DC:  MOVWF  FAD
07DE:  MOVLW  0A
07E0:  BTFSS  F9E.4
07E2:  BRA    07E0
07E4:  MOVWF  FAD
....................       output_high(GREEN);
07E6:  BCF    F96.0
07E8:  BSF    F8D.0
....................       output_low(RED);
07EA:  BCF    F96.1
07EC:  BCF    F8D.1
....................    }
.................... 
....................    // gestion du point si > que 100 !> cm -> m
....................    if(distance > 99){
07EE:  MOVF   1D,F
07F0:  BNZ   07F8
07F2:  MOVF   1C,W
07F4:  SUBLW  63
07F6:  BC    0816
....................       distance = distance / 10;
07F8:  MOVFF  1D,33
07FC:  MOVFF  1C,32
0800:  CLRF   35
0802:  MOVLW  0A
0804:  MOVWF  34
0806:  RCALL  0358
0808:  MOVFF  02,1D
080C:  MOVFF  01,1C
....................       output_high(dot);
0810:  BCF    F96.2
0812:  BSF    F8D.2
....................    }
0814:  BRA    081A
....................    else {
....................       output_low(dot);
0816:  BCF    F96.2
0818:  BCF    F8D.2
....................    }
.................... 
....................    // affichage sur 7seg de la distance
....................    output_b(outputValueParser(distance));
081A:  MOVFF  1D,30
081E:  MOVFF  1C,2F
0822:  BRA    0552
0824:  CLRF   F93
0826:  MOVFF  01,F8A
.................... 
.................... 
....................    // attente pour eviter spam
....................    delay_ms(500);
082A:  MOVLW  02
082C:  MOVWF  2F
082E:  MOVLW  FA
0830:  MOVWF  36
0832:  RCALL  0132
0834:  DECFSZ 2F,F
0836:  BRA    082E
0838:  BRA    062A
....................    }
.................... 
.................... }
083A:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   PUT NOBROWNOUT BORV25 NOWDT WDT128
   Word  3: 0000  
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
