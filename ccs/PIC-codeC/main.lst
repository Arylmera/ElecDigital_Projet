CCS PCH C Compiler, Version 5.094d, 1               27-avr.-20 14:44
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   D:\Utilisateurs\Arnaud\Documents\GitHub\ElecDigital_Projet\ccs\PIC-codeC\main.lst

               ROM used:   1970 bytes (6%)
                           Largest free fragment is 30794
               RAM used:   50 (3%) at main() level
                           65 (4%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 31

0000:  GOTO   0586
*
0008:  MOVWF  07
000A:  MOVFF  FD8,08
000E:  MOVFF  FE0,09
0012:  MOVLB  0
0014:  MOVFF  FE9,0F
0018:  MOVFF  FEA,0A
001C:  MOVFF  FE1,0B
0020:  MOVFF  FE2,0C
0024:  MOVFF  FD9,0D
0028:  MOVFF  FDA,0E
002C:  MOVFF  FF3,15
0030:  MOVFF  FF4,16
0034:  MOVFF  FFA,17
0038:  MOVFF  FF5,18
003C:  MOVFF  FF6,19
0040:  MOVFF  FF7,1A
0044:  MOVFF  00,11
0048:  MOVFF  01,12
004C:  MOVFF  02,13
0050:  MOVFF  03,14
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   00C2
0060:  MOVFF  11,00
0064:  MOVFF  12,01
0068:  MOVFF  13,02
006C:  MOVFF  14,03
0070:  MOVFF  0F,FE9
0074:  MOVFF  0A,FEA
0078:  BSF    0A.7
007A:  MOVFF  0B,FE1
007E:  MOVFF  0C,FE2
0082:  MOVFF  0D,FD9
0086:  MOVFF  0E,FDA
008A:  MOVFF  15,FF3
008E:  MOVFF  16,FF4
0092:  MOVFF  17,FFA
0096:  MOVFF  18,FF5
009A:  MOVFF  19,FF6
009E:  MOVFF  1A,FF7
00A2:  MOVF   07,W
00A4:  MOVFF  09,FE0
00A8:  MOVFF  08,FD8
00AC:  RETFIE 0
.................... #include <main.h>
.................... #include <18F458.h>
.................... //////////// Standard Header file for the PIC18F458 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F458
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 28,0C
00C0:  DATA 01,06
*
00F4:  DATA 20,50
00F6:  DATA 72,6F
00F8:  DATA 6A,65
00FA:  DATA 74,20
00FC:  DATA 45,6C
00FE:  DATA 65,63
0100:  DATA 74,72
0102:  DATA 6F,6E
0104:  DATA 69,71
0106:  DATA 75,65
0108:  DATA 20,32
010A:  DATA 30,32
010C:  DATA 30,20
010E:  DATA 00,00
0110:  DATA 47,72
0112:  DATA 6F,75
0114:  DATA 70,65
0116:  DATA 20,32
0118:  DATA 00,00
011A:  DATA 4C,69
011C:  DATA 6D,69
011E:  DATA 74,65
0120:  DATA 20,3A
0122:  DATA 20,00
*
025A:  ADDWF  FE8,W
025C:  CLRF   FF7
025E:  RLCF   FF7,F
0260:  ADDLW  75
0262:  MOVWF  FF6
0264:  MOVLW  02
0266:  ADDWFC FF7,F
0268:  TBLRD*-
026A:  MOVF   FF5,W
026C:  MOVWF  FFA
026E:  TBLRD*
0270:  MOVF   FF5,W
0272:  MOVWF  FF9
0274:  DATA 34,02
0276:  DATA 3A,02
0278:  DATA 40,02
027A:  DATA 46,02
*
02C4:  TBLRD*+
02C6:  MOVF   FF5,F
02C8:  BZ    02E2
02CA:  MOVFF  FF6,30
02CE:  MOVFF  FF7,31
02D2:  MOVFF  FF5,36
02D6:  RCALL  027C
02D8:  MOVFF  30,FF6
02DC:  MOVFF  31,FF7
02E0:  BRA    02C4
02E2:  RETURN 0
*
02F6:  CLRF   01
02F8:  CLRF   02
02FA:  CLRF   00
02FC:  CLRF   03
02FE:  MOVF   36,W
0300:  BNZ   0306
0302:  MOVF   35,W
0304:  BZ    0336
0306:  MOVLW  10
0308:  MOVWF  37
030A:  BCF    FD8.0
030C:  RLCF   33,F
030E:  RLCF   34,F
0310:  RLCF   00,F
0312:  RLCF   03,F
0314:  MOVF   36,W
0316:  SUBWF  03,W
0318:  BNZ   031E
031A:  MOVF   35,W
031C:  SUBWF  00,W
031E:  BNC   032E
0320:  MOVF   35,W
0322:  SUBWF  00,F
0324:  BTFSS  FD8.0
0326:  DECF   03,F
0328:  MOVF   36,W
032A:  SUBWF  03,F
032C:  BSF    FD8.0
032E:  RLCF   01,F
0330:  RLCF   02,F
0332:  DECFSZ 37,F
0334:  BRA    030A
0336:  RETURN 0
*
0354:  MOVF   37,W
0356:  CLRF   01
0358:  SUBWF  36,W
035A:  BC    0362
035C:  MOVFF  36,00
0360:  BRA    037A
0362:  CLRF   00
0364:  MOVLW  08
0366:  MOVWF  38
0368:  RLCF   36,F
036A:  RLCF   00,F
036C:  MOVF   37,W
036E:  SUBWF  00,W
0370:  BTFSC  FD8.0
0372:  MOVWF  00
0374:  RLCF   01,F
0376:  DECFSZ 38,F
0378:  BRA    0368
037A:  RETURN 0
037C:  MOVLW  20
037E:  BTFSS  31.4
0380:  MOVLW  30
0382:  MOVWF  32
0384:  MOVFF  30,00
0388:  BTFSS  30.7
038A:  BRA    039C
038C:  COMF   00,F
038E:  INCF   00,F
0390:  MOVFF  00,30
0394:  MOVLW  2D
0396:  MOVWF  32
0398:  BSF    31.7
039A:  BSF    31.0
039C:  MOVF   01,W
039E:  MOVFF  30,36
03A2:  MOVLW  64
03A4:  MOVWF  37
03A6:  RCALL  0354
03A8:  MOVFF  00,30
03AC:  MOVLW  30
03AE:  ADDWF  01,W
03B0:  MOVWF  33
03B2:  MOVFF  30,36
03B6:  MOVLW  0A
03B8:  MOVWF  37
03BA:  RCALL  0354
03BC:  MOVLW  30
03BE:  ADDWF  00,W
03C0:  MOVWF  35
03C2:  MOVLW  30
03C4:  ADDWF  01,W
03C6:  MOVWF  34
03C8:  MOVFF  32,00
03CC:  MOVLW  30
03CE:  SUBWF  33,W
03D0:  BZ    03DA
03D2:  BSF    31.1
03D4:  BTFSC  31.7
03D6:  BSF    31.2
03D8:  BRA    03FE
03DA:  MOVFF  32,33
03DE:  MOVLW  20
03E0:  MOVWF  32
03E2:  MOVLW  30
03E4:  SUBWF  34,W
03E6:  BZ    03F0
03E8:  BSF    31.0
03EA:  BTFSC  31.7
03EC:  BSF    31.1
03EE:  BRA    03FE
03F0:  BTFSS  FD8.2
03F2:  BSF    31.0
03F4:  BNZ   03FE
03F6:  MOVFF  33,34
03FA:  MOVLW  20
03FC:  MOVWF  33
03FE:  BTFSC  31.2
0400:  BRA    040C
0402:  BTFSC  31.1
0404:  BRA    0412
0406:  BTFSC  31.0
0408:  BRA    0418
040A:  BRA    041E
040C:  MOVFF  32,36
0410:  RCALL  027C
0412:  MOVFF  33,36
0416:  RCALL  027C
0418:  MOVFF  34,36
041C:  RCALL  027C
041E:  MOVFF  35,36
0422:  RCALL  027C
0424:  RETURN 0
*
04A0:  MOVFF  FEA,38
04A4:  MOVFF  FE9,37
04A8:  BTFSS  31.7
04AA:  BRA    04BC
04AC:  BSF    37.7
04AE:  BTFSS  37.4
04B0:  INCF   37,F
04B2:  COMF   30,F
04B4:  COMF   31,F
04B6:  INCF   30,F
04B8:  BTFSC  FD8.2
04BA:  INCF   31,F
04BC:  SWAPF  31,W
04BE:  IORLW  F0
04C0:  MOVWF  33
04C2:  ADDWF  33,F
04C4:  ADDLW  E2
04C6:  MOVWF  34
04C8:  ADDLW  32
04CA:  MOVWF  36
04CC:  MOVF   31,W
04CE:  ANDLW  0F
04D0:  ADDWF  34,F
04D2:  ADDWF  34,F
04D4:  ADDWF  36,F
04D6:  ADDLW  E9
04D8:  MOVWF  35
04DA:  ADDWF  35,F
04DC:  ADDWF  35,F
04DE:  SWAPF  30,W
04E0:  ANDLW  0F
04E2:  ADDWF  35,F
04E4:  ADDWF  36,F
04E6:  RLCF   35,F
04E8:  RLCF   36,F
04EA:  COMF   36,F
04EC:  RLCF   36,F
04EE:  MOVF   30,W
04F0:  ANDLW  0F
04F2:  ADDWF  36,F
04F4:  RLCF   33,F
04F6:  MOVLW  07
04F8:  MOVWF  32
04FA:  MOVLW  0A
04FC:  DECF   35,F
04FE:  ADDWF  36,F
0500:  BNC   04FC
0502:  DECF   34,F
0504:  ADDWF  35,F
0506:  BNC   0502
0508:  DECF   33,F
050A:  ADDWF  34,F
050C:  BNC   0508
050E:  DECF   32,F
0510:  ADDWF  33,F
0512:  BNC   050E
0514:  CLRF   FEA
0516:  MOVLW  32
0518:  MOVWF  FE9
051A:  MOVLW  07
051C:  ANDWF  37,W
051E:  BCF    37.6
0520:  MOVF   FED,F
0522:  ANDWF  37,W
0524:  BNZ   0534
0526:  BTFSC  37.4
0528:  MOVF   FEE,F
052A:  BTFSC  37.4
052C:  BRA    0534
052E:  MOVLW  20
0530:  MOVWF  00
0532:  BRA    0574
0534:  ADDWF  FE9,F
0536:  MOVLW  00
0538:  ADDWFC FEA,F
053A:  MOVF   FE9,W
053C:  SUBLW  36
053E:  BNZ   0546
0540:  MOVF   FEA,F
0542:  BNZ   0546
0544:  BSF    37.6
0546:  MOVF   FEF,W
0548:  MOVWF  00
054A:  BNZ   055C
054C:  BTFSC  37.6
054E:  BRA    055C
0550:  BTFSC  37.4
0552:  BRA    057C
0554:  BTFSC  37.3
0556:  BRA    055C
0558:  MOVLW  20
055A:  BRA    0572
055C:  BTFSS  37.7
055E:  BRA    056C
0560:  MOVLW  2D
0562:  MOVWF  00
0564:  MOVF   FED,W
0566:  BCF    37.6
0568:  BCF    37.7
056A:  BRA    0574
056C:  BSF    37.3
056E:  BCF    37.4
0570:  MOVLW  30
0572:  ADDWF  00,F
0574:  MOVF   00,W
0576:  BTFSS  F9E.4
0578:  BRA    0576
057A:  MOVWF  FAD
057C:  MOVF   FEE,W
057E:  BTFSS  37.6
0580:  BRA    053A
0582:  GOTO   079C (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=16
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... 
.................... #use delay(crystal=20MHz)
*
0124:  CLRF   FEA
0126:  MOVLW  37
0128:  MOVWF  FE9
012A:  MOVF   FEF,W
012C:  BZ    0148
012E:  MOVLW  06
0130:  MOVWF  01
0132:  CLRF   00
0134:  DECFSZ 00,F
0136:  BRA    0134
0138:  DECFSZ 01,F
013A:  BRA    0132
013C:  MOVLW  7B
013E:  MOVWF  00
0140:  DECFSZ 00,F
0142:  BRA    0140
0144:  DECFSZ FEF,F
0146:  BRA    012E
0148:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=0,rcv=0,bits=8,stream=PORT1)
.................... 
.................... #define LED PIN_None
.................... #define DELAY 1000
.................... 
.................... 
.................... 
.................... #include "LCD420.c"
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD420.C                               ////
.................... ////            Driver for common 4x20 LCD modules                      ////
.................... ////                                                                    ////
.................... ////  lcd_init()   Must be called before any other function.            ////
.................... ////                                                                    ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.      ////
.................... ////                     The following have special meaning:            ////
.................... ////                      \f  Clear display                             ////
.................... ////                      \n  Go to start of second line                ////
.................... ////                      \b  Move back one position                    ////
.................... ////                                                                    ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)     ////
.................... ////                                                                    ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD          ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... // As defined in the following structure the pin connection is as follows:
.................... //     B0  enable
.................... //     B1  rs
.................... //     B2  rw
.................... //     B4  D4
.................... //     B5  D5
.................... //     B6  D6
.................... //     B7  D7
.................... //
.................... //   LCD pins D0-D3 are not used and PIC B3 is not used.
.................... 
.................... struct lcd_pin_map {                 // This structure is overlayed
....................            BOOLEAN enable;           // on to an I/O port to gain
....................            BOOLEAN rs;               // access to the LCD pins.
....................            BOOLEAN rw;               // The bits are allocated from
....................            BOOLEAN unused;           // low order up.  ENABLE will
....................            int     data : 4;         // be pin B0.
....................         } lcd;
.................... 
.................... #byte lcd = 6                        // This puts the entire structure
....................                                      // on to port B (at address 6)
.................... 
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines
.................... 
.................... 
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6};
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
.................... 
.................... 
....................                              // The following are used for setting
....................                              // the I/O port direction register.
.................... 
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in
.................... 
.................... 
.................... BYTE lcdline;
.................... 
.................... BYTE lcd_read_byte() {
....................       BYTE low,high;
.................... 
....................       set_tris_b(LCD_READ);
*
0168:  MOVLW  F0
016A:  MOVWF  F93
....................       lcd.rw = 1;
016C:  BSF    06.2
....................       delay_cycles(1);
016E:  NOP   
....................       lcd.enable = 1;
0170:  BSF    06.0
....................       delay_cycles(1);
0172:  NOP   
....................       high = lcd.data;
0174:  SWAPF  06,W
0176:  ANDLW  0F
0178:  MOVWF  3D
....................       lcd.enable = 0;
017A:  BCF    06.0
....................       delay_cycles(1);
017C:  NOP   
....................       lcd.enable = 1;
017E:  BSF    06.0
....................       delay_us(1);
0180:  BRA    0182
0182:  BRA    0184
0184:  NOP   
....................       low = lcd.data;
0186:  SWAPF  06,W
0188:  ANDLW  0F
018A:  MOVWF  3C
....................       lcd.enable = 0;
018C:  BCF    06.0
....................       set_tris_b(LCD_WRITE);
018E:  MOVLW  00
0190:  MOVWF  F93
....................       return( (high<<4) | low);
0192:  SWAPF  3D,W
0194:  MOVWF  00
0196:  MOVLW  F0
0198:  ANDWF  00,F
019A:  MOVF   00,W
019C:  IORWF  3C,W
019E:  MOVWF  01
01A0:  GOTO   01A8 (RETURN)
.................... }
.................... 
.................... 
.................... void lcd_send_nibble( BYTE n ) {
....................       lcd.data = n;
*
014A:  SWAPF  3D,W
014C:  ANDLW  F0
014E:  MOVWF  00
0150:  MOVLW  0F
0152:  ANDWF  06,W
0154:  IORWF  00,W
0156:  MOVWF  06
....................       delay_cycles(1);
0158:  NOP   
....................       lcd.enable = 1;
015A:  BSF    06.0
....................       delay_us(2);
015C:  MOVLW  03
015E:  MOVWF  00
0160:  DECFSZ 00,F
0162:  BRA    0160
....................       lcd.enable = 0;
0164:  BCF    06.0
0166:  RETURN 0
.................... }
.................... 
.................... 
.................... void lcd_send_byte( BYTE address, BYTE n ) {
.................... 
....................       lcd.rs = 0;
*
01A4:  BCF    06.1
....................       while ( bit_test(lcd_read_byte(),7) ) ;
01A6:  BRA    0168
01A8:  MOVFF  01,3C
01AC:  BTFSC  01.7
01AE:  BRA    01A6
....................       lcd.rs = address;
01B0:  BCF    06.1
01B2:  BTFSC  3A.0
01B4:  BSF    06.1
....................       delay_cycles(1);
01B6:  NOP   
....................       lcd.rw = 0;
01B8:  BCF    06.2
....................       delay_cycles(1);
01BA:  NOP   
....................       lcd.enable = 0;
01BC:  BCF    06.0
....................       lcd_send_nibble(n >> 4);
01BE:  SWAPF  3B,W
01C0:  MOVWF  3C
01C2:  MOVLW  0F
01C4:  ANDWF  3C,F
01C6:  MOVFF  3C,3D
01CA:  RCALL  014A
....................       lcd_send_nibble(n & 0xf);
01CC:  MOVF   3B,W
01CE:  ANDLW  0F
01D0:  MOVWF  3C
01D2:  MOVWF  3D
01D4:  RCALL  014A
01D6:  RETURN 0
.................... }
.................... 
.................... 
.................... void lcd_init() {
....................     BYTE i;
.................... 
....................     set_tris_b(LCD_WRITE);
01D8:  MOVLW  00
01DA:  MOVWF  F93
....................     lcd.rs = 0;
01DC:  BCF    06.1
....................     lcd.rw = 0;
01DE:  BCF    06.2
....................     lcd.enable = 0;
01E0:  BCF    06.0
....................     delay_ms(15);
01E2:  MOVLW  0F
01E4:  MOVWF  37
01E6:  RCALL  0124
....................     for(i=1;i<=3;++i) {
01E8:  MOVLW  01
01EA:  MOVWF  30
01EC:  MOVF   30,W
01EE:  SUBLW  03
01F0:  BNC   0202
....................        lcd_send_nibble(3);
01F2:  MOVLW  03
01F4:  MOVWF  3D
01F6:  RCALL  014A
....................        delay_ms(5);
01F8:  MOVLW  05
01FA:  MOVWF  37
01FC:  RCALL  0124
01FE:  INCF   30,F
0200:  BRA    01EC
....................     }
....................     lcd_send_nibble(2);
0202:  MOVLW  02
0204:  MOVWF  3D
0206:  RCALL  014A
....................     for(i=0;i<=3;++i)
0208:  CLRF   30
020A:  MOVF   30,W
020C:  SUBLW  03
020E:  BNC   0222
....................        lcd_send_byte(0, LCD_INIT_STRING[i]);
0210:  CLRF   03
0212:  MOVF   30,W
0214:  RCALL  00AE
0216:  MOVWF  31
0218:  CLRF   3A
021A:  MOVWF  3B
021C:  RCALL  01A4
021E:  INCF   30,F
0220:  BRA    020A
0222:  GOTO   05E2 (RETURN)
.................... }
.................... 
.................... 
.................... void lcd_gotoxy( BYTE x, BYTE y) {
....................    BYTE address;
.................... 
....................    switch(y) {
0226:  MOVLW  01
0228:  SUBWF  38,W
022A:  ADDLW  FC
022C:  BC    024A
022E:  ADDLW  04
0230:  GOTO   025A
....................      case 1 : address=0x80;break;
0234:  MOVLW  80
0236:  MOVWF  39
0238:  BRA    024A
....................      case 2 : address=0xc0;break;
023A:  MOVLW  C0
023C:  MOVWF  39
023E:  BRA    024A
....................      case 3 : address=0x94;break;
0240:  MOVLW  94
0242:  MOVWF  39
0244:  BRA    024A
....................      case 4 : address=0xd4;break;
0246:  MOVLW  D4
0248:  MOVWF  39
....................    }
....................    address+=x-1;
024A:  MOVLW  01
024C:  SUBWF  37,W
024E:  ADDWF  39,F
....................    lcd_send_byte(0,address);
0250:  CLRF   3A
0252:  MOVFF  39,3B
0256:  RCALL  01A4
0258:  RETURN 0
.................... }
.................... 
.................... void lcd_putc( char c) {
....................    switch (c) {
*
027C:  MOVF   36,W
027E:  XORLW  0C
0280:  BZ    028C
0282:  XORLW  06
0284:  BZ    02A0
0286:  XORLW  02
0288:  BZ    02AE
028A:  BRA    02B8
....................      case '\f'   : lcd_send_byte(0,1);
028C:  CLRF   3A
028E:  MOVLW  01
0290:  MOVWF  3B
0292:  RCALL  01A4
....................                    lcdline=1;
0294:  MOVLW  01
0296:  MOVWF  04
....................                    delay_ms(2);
0298:  MOVLW  02
029A:  MOVWF  37
029C:  RCALL  0124
....................                                            break;
029E:  BRA    02C2
....................      case '\n'   : lcd_gotoxy(1,++lcdline);        break;
02A0:  INCF   04,F
02A2:  MOVLW  01
02A4:  MOVWF  37
02A6:  MOVFF  04,38
02AA:  RCALL  0226
02AC:  BRA    02C2
....................      case '\b'   : lcd_send_byte(0,0x10);  break;
02AE:  CLRF   3A
02B0:  MOVLW  10
02B2:  MOVWF  3B
02B4:  RCALL  01A4
02B6:  BRA    02C2
....................      default     : lcd_send_byte(1,c);     break;
02B8:  MOVLW  01
02BA:  MOVWF  3A
02BC:  MOVFF  36,3B
02C0:  RCALL  01A4
....................    }
02C2:  RETURN 0
.................... }
.................... 
.................... char lcd_getc( BYTE x, BYTE y) {
....................    char value;
.................... 
....................     lcd_gotoxy(x,y);
....................     lcd.rs=1;
....................     value = lcd_read_byte();
....................     lcd.rs=0;
....................     return(value);
.................... }
.................... 
.................... 
.................... #use fast_io(C)
.................... 
.................... #use rs232(baud=9600, parity=N, xmit=PIN_C6, rcv=PIN_C7)
.................... 
.................... #define trigger pin_C0
.................... #define echo pin_C1
.................... #define dot pin_E2
.................... #define RX pin_C7
.................... #define TX pin_C6
.................... #define GREEN pin_E0
.................... #define RED pin_E1
.................... 
.................... #int_TIMER1
.................... 
.................... int16 time, distance, x, i, minVal;
.................... boolean flag=0;
.................... char buffer[4];
.................... int j=0;
.................... int8 c,d,u;
.................... 
.................... #int_RDA
.................... void RDA_isr(void) {
....................   buffer[j]=getc();
*
00C2:  CLRF   03
00C4:  MOVF   2A,W
00C6:  ADDLW  26
00C8:  MOVWF  FE9
00CA:  MOVLW  00
00CC:  ADDWFC 03,W
00CE:  MOVWF  FEA
00D0:  BTFSS  F9E.5
00D2:  BRA    00D0
00D4:  MOVFF  FAE,FEF
....................   if(buffer[0]=='!' && flag==0) {
00D8:  MOVF   26,W
00DA:  SUBLW  21
00DC:  BNZ   00EE
00DE:  BTFSC  05.0
00E0:  BRA    00EE
....................     j++;
00E2:  INCF   2A,F
....................     if(j>=4) {
00E4:  MOVF   2A,W
00E6:  SUBLW  03
00E8:  BC    00EE
....................       j=0;
00EA:  CLRF   2A
....................       flag=1;
00EC:  BSF    05.0
....................     }
....................   }
00EE:  BCF    F9E.5
00F0:  GOTO   0060
.................... }
.................... 
.................... /*
.................... * transofmation de la valeur en valeur base 16
.................... */
.................... int16 outputValueParser(int16 value){
*
0426:  CLRF   32
....................    int output = 0;
....................    if (value < 10) { output = value;}
0428:  MOVF   31,F
042A:  BNZ   0438
042C:  MOVF   30,W
042E:  SUBLW  09
0430:  BNC   0438
0432:  MOVFF  30,32
0436:  BRA    0496
....................    else {
....................     x = value;
0438:  MOVFF  31,21
043C:  MOVFF  30,20
....................     x = x % 10;
0440:  MOVFF  21,34
0444:  MOVFF  20,33
0448:  CLRF   36
044A:  MOVLW  0A
044C:  MOVWF  35
044E:  RCALL  02F6
0450:  MOVFF  00,20
0454:  MOVFF  03,21
....................     i = value;
0458:  MOVFF  31,23
045C:  MOVFF  30,22
....................     i = i/10;
0460:  MOVFF  23,34
0464:  MOVFF  22,33
0468:  CLRF   36
046A:  MOVLW  0A
046C:  MOVWF  35
046E:  RCALL  02F6
0470:  MOVFF  02,23
0474:  MOVFF  01,22
.................... 
....................     output = x + i*16;
0478:  RLCF   22,W
047A:  MOVWF  02
047C:  RLCF   23,W
047E:  MOVWF  03
0480:  RLCF   02,F
0482:  RLCF   03,F
0484:  RLCF   02,F
0486:  RLCF   03,F
0488:  RLCF   02,F
048A:  RLCF   03,F
048C:  MOVLW  F0
048E:  ANDWF  02,F
0490:  MOVF   02,W
0492:  ADDWF  20,W
0494:  MOVWF  32
....................    }
....................    return output;
0496:  MOVFF  32,01
049A:  CLRF   02
049C:  GOTO   0788 (RETURN)
.................... }
.................... 
.................... /*
.................... * parsing temps => distance
.................... */
.................... int16 parseDist(int16 time){
....................   //return time / (285) ; // theoriquement 343 m/s
....................   return time/100;
*
0338:  MOVFF  31,34
033C:  MOVFF  30,33
0340:  CLRF   36
0342:  MOVLW  64
0344:  MOVWF  35
0346:  RCALL  02F6
0348:  MOVFF  02,03
034C:  MOVFF  02,02
0350:  GOTO   065E (RETURN)
.................... }
.................... 
.................... /*
.................... * trigger de la sonde
.................... */
.................... void triggerSonde(){
....................    output_high(trigger);
*
02E4:  BSF    F8B.0
....................    delay_us(10);
02E6:  MOVLW  10
02E8:  MOVWF  00
02EA:  DECFSZ 00,F
02EC:  BRA    02EA
02EE:  NOP   
....................    output_low(trigger);
02F0:  BCF    F8B.0
02F2:  GOTO   0640 (RETURN)
.................... }
.................... 
.................... /*
.................... * Fonctione d'initalisation du LCD
.................... *
.................... void init_lcd(){
....................    delay_ms(500);
....................    lcd_putc('\f');
....................    lcd_gotoxy(1,1);
....................    printf(lcd_putc," Projet Electronique 2020 ");
....................    delay_ms(1000);
....................    printf(lcd_putc,"Groupe 2");
....................    delay_ms(1000);
....................    lcd_putc('\f');
.................... }*/
.................... 
.................... /*
.................... * fonction principale
.................... */
.................... void main()
*
0586:  CLRF   FF8
0588:  BCF    FD0.7
058A:  BSF    0A.7
058C:  BSF    00.0
058E:  MOVLW  81
0590:  MOVWF  FAF
0592:  MOVLW  A6
0594:  MOVWF  FAC
0596:  MOVLW  90
0598:  MOVWF  FAB
059A:  BCF    05.0
059C:  CLRF   2A
059E:  CLRF   2F
05A0:  CLRF   2E
05A2:  BSF    FC1.0
05A4:  BSF    FC1.1
05A6:  BSF    FC1.2
05A8:  BCF    FC1.3
05AA:  MOVLW  07
05AC:  MOVWF  FB4
.................... {
....................    setup_low_volt_detect(FALSE);
05AE:  CLRF   FD2
....................    set_tris_c(0b01000010); // set RC1 as input (ECHO)
05B0:  MOVLW  42
05B2:  MOVWF  F94
.................... 
....................    setup_spi(FALSE);
05B4:  CLRF   FC6
....................    setup_wdt(WDT_OFF);
05B6:  BCF    FD1.0
....................    setup_timer_1( T1_INTERNAL | T1_DIV_BY_1  );
05B8:  MOVLW  85
05BA:  MOVWF  FCD
....................    setup_comparator(NC_NC_NC_NC);
05BC:  MOVLW  07
05BE:  MOVWF  FB4
05C0:  MOVF   F95,W
05C2:  MOVWF  F95
05C4:  MOVF   F96,W
05C6:  MOVWF  F96
05C8:  MOVLW  10
05CA:  MOVWF  00
05CC:  DECFSZ 00,F
05CE:  BRA    05CC
05D0:  NOP   
05D2:  MOVF   FB4,W
05D4:  BCF    FA1.6
....................    setup_vref(FALSE);
05D6:  CLRF   FB5
.................... 
....................    enable_interrupts(INT_RDA);
05D8:  BSF    F9D.5
....................    enable_interrupts(GLOBAL);
05DA:  MOVLW  C0
05DC:  IORWF  FF2,F
....................    setup_oscillator(False);
05DE:  CLRF   FD3
.................... 
....................    lcd_init();
05E0:  BRA    01D8
....................    delay_ms(500);
05E2:  MOVLW  02
05E4:  MOVWF  30
05E6:  MOVLW  FA
05E8:  MOVWF  37
05EA:  RCALL  0124
05EC:  DECFSZ 30,F
05EE:  BRA    05E6
....................    printf(lcd_putc,"\f");
05F0:  MOVLW  0C
05F2:  MOVWF  36
05F4:  RCALL  027C
....................    //lcd_putc('\f');
....................    lcd_gotoxy(1,1);
05F6:  MOVLW  01
05F8:  MOVWF  37
05FA:  MOVWF  38
05FC:  RCALL  0226
....................    printf(lcd_putc," Projet Electronique 2020 ");
05FE:  MOVLW  F4
0600:  MOVWF  FF6
0602:  MOVLW  00
0604:  MOVWF  FF7
0606:  RCALL  02C4
....................    delay_ms(1000);
0608:  MOVLW  04
060A:  MOVWF  30
060C:  MOVLW  FA
060E:  MOVWF  37
0610:  RCALL  0124
0612:  DECFSZ 30,F
0614:  BRA    060C
....................    printf(lcd_putc,"Groupe 2");
0616:  MOVLW  10
0618:  MOVWF  FF6
061A:  MOVLW  01
061C:  MOVWF  FF7
061E:  RCALL  02C4
....................    delay_ms(1000);
0620:  MOVLW  04
0622:  MOVWF  30
0624:  MOVLW  FA
0626:  MOVWF  37
0628:  RCALL  0124
062A:  DECFSZ 30,F
062C:  BRA    0624
....................    printf(lcd_putc,"\f");
062E:  MOVLW  0C
0630:  MOVWF  36
0632:  RCALL  027C
....................    //lcd_putc('\f');
.................... 
....................    while(true)
....................    {
.................... 
....................    // setup des valeurs
....................    time = 0;
0634:  CLRF   1D
0636:  CLRF   1C
.................... 
....................    // recuperation minValue envoye par JAVA
....................    minVal = 100;// (int16) getc();
0638:  CLRF   25
063A:  MOVLW  64
063C:  MOVWF  24
.................... 
....................    // d�clanchement de la sonde
....................    triggerSonde();
063E:  BRA    02E4
.................... 
....................    // recuperation valeur temps de la sonde
....................    while(input(echo) == 0){} // attente debut
0640:  BTFSS  F82.1
0642:  BRA    0640
....................    set_timer1(0);
0644:  CLRF   FCF
0646:  CLRF   FCE
....................    while(input(echo) == 1){} // attente fin ou overflow
0648:  BTFSC  F82.1
064A:  BRA    0648
....................    time = get_timer1();
064C:  MOVF   FCE,W
064E:  MOVWF  1C
0650:  MOVFF  FCF,1D
.................... 
....................    // temps => distance
....................    distance = parseDist(time);
0654:  MOVFF  1D,31
0658:  MOVFF  1C,30
065C:  BRA    0338
065E:  MOVFF  02,1F
0662:  MOVFF  01,1E
.................... 
....................    if(flag==1){
0666:  BTFSS  05.0
0668:  BRA    0694
....................      flag=0;
066A:  BCF    05.0
....................      c=buffer[1]-48;
066C:  MOVLW  30
066E:  SUBWF  27,W
0670:  MOVWF  2B
....................      d=buffer[2]-48;
0672:  MOVLW  30
0674:  SUBWF  28,W
0676:  MOVWF  2C
....................      u=buffer[3]-48;
0678:  MOVLW  30
067A:  SUBWF  29,W
067C:  MOVWF  2D
....................      minVal=(int16) (c*100+d*10+u);
067E:  MOVF   2B,W
0680:  MULLW  64
0682:  MOVFF  FF3,30
0686:  MOVF   2C,W
0688:  MULLW  0A
068A:  MOVF   FF3,W
068C:  ADDWF  30,W
068E:  ADDWF  2D,W
0690:  CLRF   25
0692:  MOVWF  24
....................    }
.................... 
....................    c=distance/100;
0694:  MOVFF  1F,34
0698:  MOVFF  1E,33
069C:  CLRF   36
069E:  MOVLW  64
06A0:  MOVWF  35
06A2:  RCALL  02F6
06A4:  MOVFF  01,2B
....................    d=(distance-(c*100))/10;
06A8:  MOVF   2B,W
06AA:  MULLW  64
06AC:  MOVF   FF3,W
06AE:  SUBWF  1E,W
06B0:  MOVWF  30
06B2:  MOVLW  00
06B4:  SUBWFB 1F,W
06B6:  MOVWF  31
06B8:  MOVWF  34
06BA:  MOVFF  30,33
06BE:  CLRF   36
06C0:  MOVLW  0A
06C2:  MOVWF  35
06C4:  RCALL  02F6
06C6:  MOVFF  01,2C
....................    u=(distance-(c*100))-(d*10);
06CA:  MOVF   2B,W
06CC:  MULLW  64
06CE:  MOVF   FF3,W
06D0:  SUBWF  1E,W
06D2:  MOVWF  30
06D4:  MOVLW  00
06D6:  SUBWFB 1F,W
06D8:  MOVF   2C,W
06DA:  MULLW  0A
06DC:  MOVF   FF3,W
06DE:  SUBWF  30,W
06E0:  MOVWF  2D
.................... 
....................    lcd_gotoxy(1,1);
06E2:  MOVLW  01
06E4:  MOVWF  37
06E6:  MOVWF  38
06E8:  RCALL  0226
....................    printf(lcd_putc, "Limite : ");
06EA:  MOVLW  1A
06EC:  MOVWF  FF6
06EE:  MOVLW  01
06F0:  MOVWF  FF7
06F2:  RCALL  02C4
....................    printf(lcd_putc, "%d", c);
06F4:  MOVFF  2B,30
06F8:  MOVLW  18
06FA:  MOVWF  31
06FC:  RCALL  037C
....................    printf(lcd_putc, "%d", d);
06FE:  MOVFF  2C,30
0702:  MOVLW  18
0704:  MOVWF  31
0706:  RCALL  037C
....................    printf(lcd_putc, "%d", u);
0708:  MOVFF  2D,30
070C:  MOVLW  18
070E:  MOVWF  31
0710:  RCALL  037C
.................... 
....................    // v�rification borne minVal
....................    if (distance < minVal){
0712:  MOVF   1F,W
0714:  SUBWF  25,W
0716:  BNC   073A
0718:  BNZ   0720
071A:  MOVF   24,W
071C:  SUBWF  1E,W
071E:  BC    073A
....................       // allumer red => trop proche
....................       printf("1\n");
0720:  MOVLW  31
0722:  BTFSS  F9E.4
0724:  BRA    0722
0726:  MOVWF  FAD
0728:  MOVLW  0A
072A:  BTFSS  F9E.4
072C:  BRA    072A
072E:  MOVWF  FAD
....................       output_high(RED);
0730:  BCF    F96.1
0732:  BSF    F8D.1
....................       output_low(GREEN);
0734:  BCF    F96.0
0736:  BCF    F8D.0
....................    }
0738:  BRA    0752
....................    else {
....................       // allumer green => OK
....................       printf("2\n");
073A:  MOVLW  32
073C:  BTFSS  F9E.4
073E:  BRA    073C
0740:  MOVWF  FAD
0742:  MOVLW  0A
0744:  BTFSS  F9E.4
0746:  BRA    0744
0748:  MOVWF  FAD
....................       output_high(GREEN);
074A:  BCF    F96.0
074C:  BSF    F8D.0
....................       output_low(RED);
074E:  BCF    F96.1
0750:  BCF    F8D.1
....................    }
.................... 
....................    // gestion du point si > que 100 !> cm -> m
....................    if(distance > 99){
0752:  MOVF   1F,F
0754:  BNZ   075C
0756:  MOVF   1E,W
0758:  SUBLW  63
075A:  BC    077A
....................       distance = distance / 10;
075C:  MOVFF  1F,34
0760:  MOVFF  1E,33
0764:  CLRF   36
0766:  MOVLW  0A
0768:  MOVWF  35
076A:  RCALL  02F6
076C:  MOVFF  02,1F
0770:  MOVFF  01,1E
....................       output_high(dot);
0774:  BCF    F96.2
0776:  BSF    F8D.2
....................    }
0778:  BRA    077E
....................    else {
....................       output_low(dot);
077A:  BCF    F96.2
077C:  BCF    F8D.2
....................    }
.................... 
....................    // affichage sur 7seg de la distance
....................    output_b(outputValueParser(distance));
077E:  MOVFF  1F,31
0782:  MOVFF  1E,30
0786:  BRA    0426
0788:  CLRF   F93
078A:  MOVFF  01,F8A
.................... 
....................    // envoie distance � java
....................    printf("%ld", distance);
078E:  MOVLW  10
0790:  MOVWF  FE9
0792:  MOVFF  1F,31
0796:  MOVFF  1E,30
079A:  BRA    04A0
....................    printf("\n");
079C:  MOVLW  0A
079E:  BTFSS  F9E.4
07A0:  BRA    079E
07A2:  MOVWF  FAD
.................... 
....................    // attente pour eviter spam
....................    delay_ms(500);
07A4:  MOVLW  02
07A6:  MOVWF  30
07A8:  MOVLW  FA
07AA:  MOVWF  37
07AC:  RCALL  0124
07AE:  DECFSZ 30,F
07B0:  BRA    07A8
07B2:  BRA    0634
....................    }
.................... 
.................... }
07B4:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   PUT NOBROWNOUT BORV25 NOWDT WDT128
   Word  3: 0000  
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
